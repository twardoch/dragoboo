This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory, _private, .cursorrules, CLAUDE.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.cursor/
  rules/
    alignment-algorithms.mdc
    engine-implementations.mdc
    frame-models.mdc
    video-processing-flow.mdc
.giga/
  specifications.json
Sources/
  DragobooApp/
    Assets.xcassets/
      Contents.json
    ContentView.swift
    DragobooApp.swift
  DragobooCore/
    PointerScaler.swift
Tests/
  DragobooCoreTests/
    PointerScalerTests.swift
.cursorindexingignore
.gitignore
Info.plist
Makefile
Package.swift
PLAN.md
README.md
run.sh
stop.sh
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "enableAllProjectMcpServers": false
}
</file>

<file path=".cursor/rules/alignment-algorithms.mdc">
---
description: Documents core alignment algorithms for precision cursor control and scaling in Dragoboo macOS utility
globs: Sources/DragobooCore/PointerScaler.swift,Sources/DragobooCore/EventProcessing/*.swift
alwaysApply: false
---


# alignment-algorithms

The alignment algorithms in Dragoboo focus on precise cursor movement scaling and event processing:

### Event Processing Pipeline 
- **Event Tap Creation**: System-wide event tap intercepts mouse/trackpad inputs
- **Event Type Filtering**: Processes `mouseMoved`, `leftMouseDragged`, `rightMouseDragged`, `otherMouseDragged`, and `scrollWheel` events
- **State Detection**: Continuously monitors `fn` key state through flags and polling

### Movement Scaling Algorithm
```swift
// Key implementation in Sources/DragobooCore/PointerScaler.swift
struct MovementScaler {
    private var accumulatedX: Double = 0.0
    private var accumulatedY: Double = 0.0
    
    // Scales movement by accumulating fractional values
    mutating func scaleMovement(deltaX: Double, deltaY: Double, factor: Double) -> (Int, Int) {
        accumulatedX += deltaX / factor 
        accumulatedY += deltaY / factor
        
        let scaledX = Int(accumulatedX)
        let scaledY = Int(accumulatedY)
        
        accumulatedX -= Double(scaledX)
        accumulatedY -= Double(scaledY)
        
        return (scaledX, scaledY)
    }
}
```

### Temporal State Management
- Tracks activation state of precision mode
- Manages accumulator resets during mode transitions
- Coordinates event tap lifecycle with permission state

### Key Implementation Files:
- `/Sources/DragobooCore/PointerScaler.swift`: Core scaling and event processing
- `/Sources/DragobooCore/EventProcessing/EventTap.swift`: Event interception setup
- `/Sources/DragobooCore/EventProcessing/StateManager.swift`: State coordination

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga alignment-algorithms".
</file>

<file path=".cursor/rules/engine-implementations.mdc">
---
description: Error: Failed to generate frontmatter for engine-implementations
globs: 
alwaysApply: false
---
</file>

<file path=".cursor/rules/frame-models.mdc">
---
description: Documents core data structures and models used for frame processing and analysis in the video pipeline
globs: **/FrameFingerprint.swift,**/FrameAlignment.swift,**/frame-*.{swift,h,m},**/models/*Frame*.{swift,h,m}
alwaysApply: false
---
</file>

<file path=".cursor/rules/video-processing-flow.mdc">
---
description: Error: Failed to generate frontmatter for video-processing-flow
globs: 
alwaysApply: false
---
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview describing the video overlay and synchronization architecture, key components, and their interactions"
  },
  {
    "fileName": "alignment-algorithms.mdc",
    "description": "Detailed documentation of the three core algorithms: Frame Fingerprinting, Spatial Alignment, and Temporal Alignment Engines, including implementation details and optimizations"
  },
  {
    "fileName": "video-processing-flow.mdc",
    "description": "Comprehensive documentation of the video processing pipeline, data flow between components, and how the various alignment algorithms work together during composition"
  },
  {
    "fileName": "frame-models.mdc",
    "description": "Documentation of core data models including FrameFingerprint, FrameAlignment, and related structures used throughout the video processing pipeline"
  },
  {
    "fileName": "engine-implementations.mdc",
    "description": "Detailed implementation documentation for the Full and Mask temporal alignment engines, including their unique approaches and optimizations"
  }
]
</file>

<file path="Sources/DragobooApp/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Tests/DragobooCoreTests/PointerScalerTests.swift">
import XCTest
@testable import DragobooCore

final class PointerScalerTests: XCTestCase {
    func testPrecisionFactorInitialization() {
        let scaler = PointerScaler(precisionFactor: 4.0)
        XCTAssertNotNil(scaler)
    }
    
    func testPrecisionFactorUpdate() {
        let scaler = PointerScaler(precisionFactor: 4.0)
        scaler.updatePrecisionFactor(8.0)
        XCTAssertNotNil(scaler)
    }
}
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path="Package.swift">
// swift-tools-version: 5.10
import PackageDescription

let package = Package(
    name: "Dragoboo",
    platforms: [
        .macOS(.v13)
    ],
    products: [
        .executable(
            name: "Dragoboo",
            targets: ["DragobooApp"]
        ),
        .library(
            name: "DragobooCore",
            targets: ["DragobooCore"]
        ),
    ],
    dependencies: [],
    targets: [
        .executableTarget(
            name: "DragobooApp",
            dependencies: ["DragobooCore"],
            resources: [
                .process("Assets.xcassets")
            ]
        ),
        .target(
            name: "DragobooCore",
            dependencies: []
        ),
        .testTarget(
            name: "DragobooCoreTests",
            dependencies: ["DragobooCore"]
        ),
    ]
)
</file>

<file path="PLAN.md">
# Dragoboo Development Plan

## Phase 1: Research & Architecture

[ ] Analyze CGEventTap API documentation for mouse event interception
[ ] Research fn key detection methods (CGEventFlags vs keyState polling)
[ ] Investigate accessibility permission handling and user flow
[ ] Document technical constraints and edge cases
[ ] Design modular architecture (DragobooCore + DragobooApp)
[ ] Create system architecture diagram
[ ] Define public API surface for DragobooCore
[ ] Research battery impact mitigation strategies

## Phase 2: Project Setup & Infrastructure

[ ] Create Xcode project with macOS app template
[ ] Configure SwiftUI lifecycle and minimum deployment target (macOS 13.0)
[ ] Set up Swift Package Manager structure
[ ] Create DragobooCore package with proper module organization
[ ] Configure code signing and Developer ID certificate
[ ] Set up SwiftLint with appropriate rules
[ ] Configure swift-format for code consistency
[ ] Create .gitignore with Xcode/Swift patterns
[ ] Initialize git repository with proper structure

## Phase 3: Core Functionality Implementation

[ ] Implement PointerScalerActor for thread-safe event processing
[ ] Create CGEventTap wrapper with proper error handling
[ ] Implement mouse delta scaling algorithm
[ ] Add fn key detection via maskSecondaryFn flag
[ ] Create fallback keyState polling for fn key
[ ] Implement event tap lifecycle management
[ ] Add automatic re-enable for disabled taps
[ ] Create scaling factor validation (0.5-10x range)
[ ] Implement smooth transition between normal/precision modes
[ ] Add support for all mouse event types (move, drag, scroll)

## Phase 4: Modifier Key Management

[ ] Create KeyStateManager for modifier tracking
[ ] Implement flagsChanged event monitoring
[ ] Add support for custom modifier keys beyond fn
[ ] Create modifier key combination support
[ ] Implement edge case handling for stuck keys
[ ] Add modifier state persistence across app switches
[ ] Create debugging output for key state changes

## Phase 5: User Interface Development

[ ] Design MenuBarExtra with SwiftUI
[ ] Create status bar icon (normal vs active states)
[ ] Implement preferences sheet UI
[ ] Add precision factor slider/stepper control
[ ] Create modifier key selection interface
[ ] Implement live preview of settings changes
[ ] Add visual feedback for precision mode activation
[ ] Design onboarding flow for first launch
[ ] Create accessibility permission request UI

## Phase 6: System Integration

[ ] Implement accessibility permission checking
[ ] Create AXIsProcessTrustedWithOptions wrapper
[ ] Add permission status monitoring
[ ] Implement graceful degradation without permissions
[ ] Create LaunchAgent for login startup
[ ] Add proper app termination cleanup
[ ] Implement system sleep/wake handling
[ ] Add display configuration change support

## Phase 7: Performance Optimization

[ ] Profile event tap callback performance
[ ] Implement sub-1ms callback execution
[ ] Add event rate limiting (120 Hz max)
[ ] Create dedicated high-priority dispatch queue
[ ] Minimize CPU usage when idle
[ ] Implement memory usage monitoring
[ ] Add performance metrics logging
[ ] Optimize for battery efficiency

## Phase 8: Persistence & Configuration

[ ] Implement UserDefaults integration with @AppStorage
[ ] Create settings migration system
[ ] Add configuration import/export
[ ] Implement preset management
[ ] Create per-application settings support
[ ] Add backup/restore functionality

## Phase 9: Error Handling & Logging

[ ] Set up os.Logger infrastructure
[ ] Implement comprehensive error handling
[ ] Create user-friendly error messages
[ ] Add crash reporting integration
[ ] Implement diagnostic data collection
[ ] Create debug mode with verbose logging
[ ] Add event tap failure recovery

## Phase 10: Testing Strategy

[ ] Write unit tests for scaling math
[ ] Create integration tests for event processing
[ ] Implement UI tests for preferences
[ ] Add performance benchmarks
[ ] Test with multiple input devices
[ ] Verify behavior across macOS versions
[ ] Test with external keyboards (fn key compatibility)
[ ] Create automated test suite

## Phase 11: Edge Cases & Compatibility

[ ] Handle multiple displays with different DPIs
[ ] Test with gaming mice (high DPI)
[ ] Verify Magic Trackpad compatibility
[ ] Handle Bluetooth disconnection/reconnection
[ ] Test with Touch Bar MacBooks
[ ] Verify M1/M2/M3 compatibility
[ ] Handle full screen games/apps
[ ] Test with virtual machines

## Phase 12: Documentation

[ ] Write comprehensive README
[ ] Create user guide with screenshots
[ ] Document accessibility setup process
[ ] Write API documentation for DragobooCore
[ ] Create troubleshooting guide
[ ] Document known limitations
[ ] Write contribution guidelines
[ ] Create changelog structure

## Phase 13: Distribution & Packaging

[ ] Configure hardened runtime
[ ] Set up notarization workflow
[ ] Create DMG installer with background
[ ] Implement auto-update mechanism (Sparkle)
[ ] Create Homebrew cask formula
[ ] Set up GitHub releases automation
[ ] Create installation verification
[ ] Implement license validation (if commercial)

## Phase 14: Quality Assurance

[ ] Perform thorough manual testing
[ ] Run static analysis tools
[ ] Check for memory leaks
[ ] Verify accessibility compliance
[ ] Test localization support
[ ] Validate security best practices
[ ] Performance regression testing
[ ] User acceptance testing

## Phase 15: Release & Post-Launch

[ ] Create marketing website
[ ] Set up user feedback channels
[ ] Implement analytics (privacy-respecting)
[ ] Create support documentation
[ ] Monitor crash reports
[ ] Plan feature roadmap
[ ] Set up community forum
[ ] Establish update cadence
</file>

<file path="README.md">
# Dragoboo 🐉🖱️

**Dragoboo is a macOS utility designed to give you an instant precision boost for your trackpad and mouse. By simply holding down the `fn` key, you can temporarily slow down your cursor movement, allowing for finer control in detailed tasks.**

Whether you're a designer pixel-peeping in an image editor, an engineer working with CAD software, or just someone who occasionally needs that extra bit of accuracy, Dragoboo aims to make your pointer interactions smoother and more precise without interrupting your workflow.

[![macOS](https://img.shields.io/badge/macOS-13.0+-blue.svg)](https://www.apple.com/macos) [![Swift](https://img.shields.io/badge/Swift-5.10-orange.svg)](https://swift.org) [![SwiftUI](https://img.shields.io/badge/SwiftUI-Framework-purple.svg)](https://developer.apple.com/xcode/swiftui/) [![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE) ## Table of Contents

- [Features](#features)
- [Why Dragoboo?](#why-dragoboo)
- [User Experience (UX)](#user-experience-ux)
  - [Installation](#installation)
  - [First Launch & Permissions](#first-launch--permissions)
  - [Usage](#usage)
  - [Settings](#settings)
- [Technical Deep Dive](#technical-deep-dive)
  - [Core Architecture](#core-architecture)
  - [Event Handling](#event-handling)
  - [State Management](#state-management)
  - [Key Components](#key-components)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Building from Source](#building-from-source)
    - [Using the Command Line (Recommended)](#using-the-command-line-recommended)
    - [Using Xcode](#using-xcode)
  - [Running the App](#running-the-app)
  - [Stopping the App](#stopping-the-app)
- [Configuration](#configuration)
- [Privacy & Security](#privacy--security)
- [Development Insights](#development-insights)
  - [Project Structure](#project-structure)
  - [Planning & Roadmap](#planning--roadmap)
  - [Testing](#testing)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Acknowledgements](#acknowledgements)

## Features

- **Instant Precision Mode:** Hold the `fn` key to temporarily reduce cursor sensitivity.
- **Customizable Slowdown Factor:** Adjust how much the cursor slows down (from 1x to 10x) via a simple slider in the menu bar popover. Default is 4x.
- **Menu Bar App:** Lives discreetly in your macOS menu bar, providing quick access to settings without cluttering your Dock.
- **Universal Support:** Works with both built-in trackpads and external mice.
- **Comprehensive Action Coverage:** Precision mode applies to standard cursor movements, dragging actions (left, right, other), and even scroll wheel events.
- **SwiftUI Interface:** Modern and clean user interface for settings.
- **Lightweight:** Designed to be efficient and have minimal impact on system performance.
- **Accessibility Focused:** Requires and guides users through granting necessary Accessibility permissions.

## Why Dragoboo?

Many creative and technical tasks on a Mac require precise cursor placement. While macOS offers global tracking speed adjustments, these are cumbersome to change frequently. Dragoboo provides an "on-demand" precision mode, activated by a key you already have: the `fn` key. This allows for quick switching between fast navigation and meticulous control without needing to dive into System Settings or use complex third-party tools.

The core idea was born out of a need for finer trackpad control during detailed graphical work, as detailed in the initial [research document (`_private/research.md`)](_private/research.md).

## User Experience (UX)

### Installation

Dragoboo is typically run from the build output. Once built (see [Building from Source](#building-from-source)), the `Dragoboo.app` bundle can be placed in your `/Applications` folder or run from any location.

### First Launch & Permissions

Upon first launch, Dragoboo will check if it has the necessary **Accessibility permissions**. These permissions are crucial for the app to monitor and modify mouse/trackpad events system-wide.

1.  If permissions are not granted, the app's menu bar popover will display a message prompting you to grant them.
2.  Clicking the "Grant Permission" button will attempt to open **System Settings > Privacy & Security > Accessibility**.
3.  You will need to find "Dragoboo" in the list and enable it. You might need to unlock System Settings with your administrator password.

Without these permissions, Dragoboo cannot function.

### Usage

Once installed and permissions are granted:

1.  **Launch Dragoboo:** The app icon (a cursor arrow) will appear in your macOS menu bar.
2.  **Activate Precision Mode:** Simply **press and hold the `fn` key** on your keyboard. While the `fn` key is held, your cursor (and scrolling) will move significantly slower, based on the configured slowdown factor.
3.  **Release `fn` Key:** Release the `fn` key to return to normal cursor speed.

The menu bar icon will change to indicate when precision mode is active (e.g., from `cursorarrow` to `cursorarrow.click.2`).

### Settings

Click the Dragoboo icon in the menu bar to open a small popover window:

- **Accessibility Status:** Shows if permissions are granted.
- **Slowdown Factor Slider:** Adjust the precision multiplier from 1x (no slowdown) to 10x. The default is 4x. Changes are applied live.
- **Precision Mode Indicator:** A label confirms "Precision mode active" when the `fn` key is held.
- **Status Indicator:** A small circle (gray for ready, green for active) and text provide a quick visual cue.
- **Quit Button:** To close the application.

## Technical Deep Dive

### Core Architecture

Dragoboo follows a modular design:

- **`DragobooApp` (SwiftUI Application):**

  - Manages the main application lifecycle.
  - Provides the `MenuBarExtra` user interface using SwiftUI.
  - Hosts the `AppState` observable object to bridge UI and core logic.
  - Located in `Dragoboo/Dragoboo/DragobooApp.swift`.

- **`DragobooCore` (Swift Package):**
  - Contains the core logic for event handling and pointer scaling.
  - This separation allows the core functionality to be potentially reused or tested independently.
  - The primary class here is `PointerScaler`.
  - Located in `Sources/DragobooCore/`.

### Event Handling

The heart of Dragoboo is its ability to intercept and modify system-wide input events. This is achieved using macOS's **Quartz Event Services**, specifically `CGEvent.tapCreate`:

1.  **Event Tap Creation:** An event tap is established at the `.cgSessionEventTap` point, placed at `.headInsertEventTap` to process events before other applications.
2.  **Events of Interest:** The tap listens for:
    - `mouseMoved`
    - `leftMouseDragged`, `rightMouseDragged`, `otherMouseDragged`
    - `scrollWheel`
    - `flagsChanged` (to detect `fn` key state changes)
3.  **Callback Mechanism:** A C-style callback function (`eventTapCallback` in the initial research, now encapsulated within `PointerScaler`) is invoked for each relevant event.
4.  **`fn` Key Detection:**
    - The primary method is checking the `flags` of an incoming event for `.maskSecondaryFn`. This is handled within the `flagsChanged` event type.
    - As a fallback and for continuous state checking during mouse/scroll events, `CGEventSource.keyState(.combinedSessionState, key: 0x3F)` is used to poll the `fn` key's state (key code `0x3F` is for `fn`).
5.  **Delta Scaling:**
    - When the `fn` key is detected as pressed, the `PointerScaler` retrieves the delta values from mouse movement or scroll wheel events (e.g., `.mouseEventDeltaX`, `.mouseEventDeltaY`, `.scrollWheelEventDeltaAxis1`).
    - These delta values are then divided by the `precisionFactor`.
    - The modified delta values are written back into the event using `setDoubleValueField`.
    - The modified event is then passed on to the system.
6.  **Run Loop Integration:** The event tap is added to the current run loop to ensure it processes events continuously.
7.  **Error Handling:** The system includes logging for event tap creation failures and attempts to re-enable the tap if it's disabled by timeout or user input.

### State Management

- **`AppState` (ObservableObject):** This class in `DragobooApp.swift` serves as the central point for managing the application's state and acts as a ViewModel.
  - `@Published var isPrecisionModeActive`: Tracks if the `fn` key is currently pressed.
  - `@Published var isAccessibilityGranted`: Reflects the status of Accessibility permissions.
  - `@AppStorage("precisionFactor") var precisionFactor: Double`: Persists the user-selected slowdown factor using `UserDefaults`.
  - It initializes and manages the `PointerScaler` instance from `DragobooCore`.
  - Communicates changes from `PointerScaler` (like `fn` key state) to the SwiftUI UI via its `onPrecisionModeChange` callback.

### Key Components

- **`DragobooApp.swift`:**
  - `DragobooApp`: The main `@main` struct defining the app and its `MenuBarExtra` scene.
  - `AppState`: Manages overall application state, permissions, and interaction with `PointerScaler`.
- **`ContentView.swift`:**
  - `ContentView`: The main SwiftUI view for the menu bar popover.
  - `AccessibilityRequestView`: Shown if permissions are not granted.
  - `PrecisionSettingsView`: Allows adjustment of the slowdown factor.
  - `StatusIndicator`: Visual feedback for precision mode.
- **`PointerScaler.swift` (in `DragobooCore`):**
  - The core engine responsible for creating and managing the `CGEventTap`.
  - Handles event callbacks, `fn` key detection logic, and scaling of mouse/scroll deltas.
  - Provides an `onPrecisionModeChange` callback to notify `AppState` of `fn` key status.
  - Manages its own lifecycle with `start()` and `stop()` methods.
- **`Info.plist`:**
  - Configures the app as a "UI Element" (`LSUIElement = true`), so it runs as a menu bar agent without a Dock icon.
  - Specifies the minimum macOS deployment target.

## Getting Started

### Prerequisites

- **macOS:** Version 13.0 or later.
- **Xcode:** Version 15.0 or later (for building from source).
- **Xcode Command Line Tools:** Required for `xcodebuild`. Install via `xcode-select --install`.
- **(Optional) `xcpretty`:** For nicer build output in the terminal. Install via `gem install xcpretty`. The `run.sh` script will fall back if it's not found.

### Building from Source

You can build Dragoboo using the provided shell script or directly within Xcode.

#### Using the Command Line (Recommended)

The repository includes a `run.sh` script to simplify the build and run process.

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd dragoboo
    ```
2.  **Make scripts executable (if needed):**
    ```bash
    chmod +x run.sh stop.sh
    ```
3.  **Build and Run:**

    ```bash
    ./run.sh
    ```

    This will:

    - Clean the build directory (optional, can be forced with `--clean`).
    - Build the app in Debug configuration.
    - Launch the app.

4.  **Other `run.sh` options:**

    - `./run.sh --help`: Show all available script options.
    - `./run.sh --release`: Build in Release configuration.
    - `./run.sh --clean`: Force a clean build before building.
    - `./run.sh --no-launch`: Build the app but do not launch it.

    A `Makefile` is also provided for common tasks:

    ```bash
    make          # Build and run (default)
    make build    # Build without running
    make clean    # Clean build directory
    make release  # Build release version
    make rebuild  # Clean and then build
    make help     # Show Makefile help
    ```

#### Using Xcode

1.  Open `Dragoboo.xcodeproj` in Xcode.
2.  Select the "Dragoboo" scheme and a macOS run destination (My Mac).
3.  Click the "Build and Run" button (or press `⌘R`).

### Running the App

After building, the `Dragoboo.app` bundle will be located in the `build/Build/Products/<Configuration>/` directory (e.g., `build/Build/Products/Debug/Dragoboo.app`).

You can launch it by:

- Using `./run.sh` (which handles launching).
- Double-clicking `Dragoboo.app` in Finder.
- Running `open build/Build/Products/Debug/Dragoboo.app` from the terminal (adjust path if built in Release).

### Stopping the App

- Click the Dragoboo icon in the menu bar and select "Quit".
- Run `./stop.sh` from the terminal.
- If run from Xcode, stopping the process in Xcode will terminate the app.

## Configuration

The primary configuration option is the **Slowdown Factor**, adjustable from 1x to 10x using the slider in the menu bar popover. This setting is persisted across app launches using `@AppStorage` (which relies on `UserDefaults`).

## Privacy & Security

- **Accessibility Permissions:** Dragoboo **requires** Accessibility permissions in **System Settings > Privacy & Security > Accessibility**. This is essential for the app to monitor and modify mouse and keyboard events system-wide. The app will guide you to grant these permissions.
- **No Data Collection:** Dragoboo does not collect, store, or transmit any personal data.
- **No Network Connectivity:** The app does not connect to the internet.
- **Local Operation:** All event processing and modification happen locally on your Mac.
- **Targeted Modification:** Event modification only occurs when the `fn` key is actively held down.

## Development Insights

### Project Structure

Dragoboo/├── Dragoboo.xcodeproj # Xcode project file├── Dragoboo/ # Main application target group│ ├── DragobooApp.swift # App entry point, MenuBarExtra, AppState│ ├── ContentView.swift # SwiftUI views for the popover│ ├── Assets.xcassets # App icons and other assets│ └── Info.plist # Application configuration├── Sources/│ └── DragobooCore/ # Swift Package for core logic│ └── PointerScaler.swift # Event tap and scaling logic├── Tests/│ └── DragobooCoreTests/ # Unit tests for DragobooCore│ └── PointerScalerTests.swift├── \_private/│ └── research.md # Initial research and planning├── Package.swift # Swift Package Manager manifest├── README.md # This file├── PLAN.md # Detailed development plan├── TODO.md # Short-term tasks├── Makefile # Makefile for build automation├── run.sh # Build and run script└── stop.sh # Script to stop the app

### Planning & Roadmap

The development process is guided by:

- [`PLAN.md`](PLAN.md): A comprehensive checklist of development phases and deliverables, covering research, implementation, testing, and release.
- [`TODO.md`](TODO.md): A list of immediate, actionable tasks for the current development sprint.
- [`CLAUDE.md`](CLAUDE.md): Contains initial guidelines and thoughts on implementation, particularly regarding API choices and architectural decisions.

### Testing

- **Unit Tests:** Basic unit tests for `DragobooCore` are located in `Tests/DragobooCoreTests/`. These currently cover `PointerScaler` initialization and factor updates.
- **Manual Testing:** Crucial for verifying the end-to-end UX, `fn` key interaction, and behavior across different applications and input devices.

## Troubleshooting

- **App Not Working / No Slowdown:**
  1.  **Check Accessibility Permissions:** Ensure Dragoboo is enabled in **System Settings > Privacy & Security > Accessibility**. This is the most common reason for the app not functioning. Try toggling the permission off and on.
  2.  **Restart Dragoboo:** Quit the app from its menu bar icon and relaunch it.
  3.  **Check `fn` Key Configuration:** On some MacBooks, the `fn` key might be configured to perform its special feature (e.g., Show Emoji & Symbols, Start Dictation) instead of acting as a standard modifier. Check **System Settings > Keyboard > Keyboard > Press fn key to...**. For Dragoboo to work best, this should ideally be set to "Do Nothing" or a setting that doesn't conflict. Dragoboo attempts to detect the `fn` key regardless, but system-level interception might interfere.
- **`xcpretty` Not Found (during `./run.sh`):**
  - The `run.sh` script will fall back to standard `xcodebuild` output. If you want prettier output, install `xcpretty`: `sudo gem install xcpretty`.
- **CoreSimulator Version Mismatch (Build Error):**
  - This error (`CoreSimulator is out of date...`) might appear if your Xcode or macOS is not fully up-to-date, or if there's a mismatch between Xcode's components.
  - Ensure macOS and Xcode are updated to their latest compatible versions.
  - Sometimes, restarting your Mac or reinstalling Xcode Command Line Tools (`sudo rm -rf /Library/Developer/CommandLineTools; xcode-select --install`) can help. This error primarily affects simulator builds, which Dragoboo doesn't rely on for its core functionality.
- **`fn` Key on External Keyboards:**
  - The reliability of `fn` key detection can vary with third-party external keyboards. Dragoboo is primarily tested with built-in MacBook keyboards and Apple Magic Keyboards. If you experience issues, this might be a limitation.

## Contributing

Contributions are welcome! If you'd like to contribute, please:

1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Refer to `PLAN.md` and `TODO.md` for areas of development.
4.  Follow the existing code style and architectural patterns.
5.  Write tests for new functionality if applicable.
6.  Submit a pull request with a clear description of your changes.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details. _(Note: A `LICENSE` file was not explicitly provided in the source; assuming MIT as a common open-source license. Please create/update this file if a different license applies.)_

## Acknowledgements

- The initial research and problem statement that inspired Dragoboo.
- The macOS developer community for resources on `CGEventTap` and SwiftUI.

## Reminders for contributors

- **Readability > cleverness.** Clear names & comments.
- **Fail safely.** If the tap can’t activate, surface a user-friendly banner and exit.
- **Keep PLAN.md & TODO.md living documents.** Update as you learn.
- **Commit often, push daily.** Small PRs enable fast review.

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.

Dragoboo is a macOS utility that provides precision cursor control through temporary slowdown functionality.

## Core Business Logic

### Precision Control System

- Activates temporary cursor slowdown when fn key is held
- Scales both cursor movement and scroll wheel input
- Configurable slowdown factor (1x-10x)
- Persists user preferences across sessions
- Works universally with trackpads and mice

### Event Processing Pipeline

The event interception and modification system:

1. Creates system-wide event tap for mouse/trackpad inputs
2. Monitors fn key state continuously
3. Applies precision scaling to movement deltas when active
4. Handles multiple event types including movement, dragging, and scrolling

### Permission Management

- Requires macOS Accessibility permissions
- Guides users through permission granting process
- Validates permission status on launch
- Prevents operation without proper access

### State Management System

Centralizes control through AppState which:

- Tracks precision mode status
- Manages accessibility permissions
- Controls slowdown factor settings
- Coordinates UI feedback

## Critical Components

### Core Files

- `DragobooApp.swift`: Application entry point and state coordination
- `PointerScaler.swift`: Event interception and scaling engine
- `ContentView.swift`: UI feedback and settings interface

### Key Integrations

- Event tap system for system-wide input capture
- Accessibility permissions framework
- User defaults for persistence
- Menu bar integration for status and control

### Data Flow

1. System input events → Event tap
2. Event tap → Pointer scaler
3. Pointer scaler → Modified events
4. State changes → UI updates
</file>

<file path="Sources/DragobooApp/ContentView.swift">
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            if !appState.isAccessibilityGranted {
                AccessibilityRequestView()
            } else {
                PrecisionSettingsView()
            }
            
            Divider()
            
            HStack {
                Button("Quit") {
                    NSApplication.shared.terminate(nil)
                }
                .keyboardShortcut("q", modifiers: .command)
                
                Spacer()
                
                if appState.isAccessibilityGranted {
                    StatusIndicator()
                }
            }
        }
        .onAppear { 
            appState.refreshPermission() 
        }
        .padding()
        .frame(width: 300)
    }
}

struct AccessibilityRequestView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: "lock.shield")
                .font(.system(size: 48))
                .foregroundColor(.orange)
            
            Text("Accessibility Permission Required")
                .font(.headline)
            
            Text("Dragoboo needs accessibility permissions to modify cursor movement.")
                .font(.caption)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            Button("Grant Permission") {
                appState.requestAccessibility()
            }
            .controlSize(.large)
        }
    }
}

struct PrecisionSettingsView: View {
    @EnvironmentObject var appState: AppState
    @State private var sliderValue: Double = 4.0
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Precision Settings")
                .font(.headline)
            
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Text("Slowdown Factor:")
                    Spacer()
                    Text("\(Int(sliderValue))×")
                        .monospacedDigit()
                        .foregroundColor(.secondary)
                }
                
                Slider(value: $sliderValue, in: 1...10, step: 1) { _ in
                    appState.updatePrecisionFactor(sliderValue)
                }
                .onAppear {
                    sliderValue = appState.precisionFactor
                }
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Label("Hold fn key to activate precision mode", systemImage: "keyboard")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Label(
                    appState.isPrecisionModeActive ? "Precision mode active" : " ",
                    systemImage: appState.isPrecisionModeActive ? "checkmark.circle.fill" : "circle"
                )
                .font(.caption)
                .foregroundColor(appState.isPrecisionModeActive ? .green : .clear)
            }
        }
    }
}

struct StatusIndicator: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(appState.isPrecisionModeActive ? Color.green : Color.gray)
                .frame(width: 8, height: 8)
            
            Text(appState.isPrecisionModeActive ? "Active" : "Ready")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/DragobooApp/DragobooApp.swift">
import SwiftUI
import DragobooCore
import os

@main
struct DragobooApp: App {
    @StateObject private var appState = AppState()
    private let logger = Logger(subsystem: "com.dragoboo.app", category: "main")
    
    var body: some Scene {
        MenuBarExtra("Dragoboo", systemImage: "cursorarrow") {
            ContentView()
                .environmentObject(appState)
        }
        .menuBarExtraStyle(.window)
    }
}

class AppState: ObservableObject {
    @Published var isPrecisionModeActive = false
    @Published var isAccessibilityGranted = false
    @AppStorage("precisionFactor") var precisionFactor: Double = 4.0
    
    private var pointerScaler: PointerScaler?
    private let logger = Logger(subsystem: "com.dragoboo.app", category: "AppState")
    
    init() {
        checkAccessibility()
        setupPointerScaler()
    }
    
    private func checkAccessibility() {
        isAccessibilityGranted = AXIsProcessTrusted()
    }
    
    func requestAccessibility() {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
        isAccessibilityGranted = AXIsProcessTrustedWithOptions(options)
        
        if isAccessibilityGranted {
            setupPointerScaler()
        }
    }
    
    private func setupPointerScaler() {
        guard isAccessibilityGranted else { return }
        
        pointerScaler = PointerScaler(precisionFactor: precisionFactor)
        pointerScaler?.onPrecisionModeChange = { [weak self] isActive in
            DispatchQueue.main.async {
                self?.isPrecisionModeActive = isActive
            }
        }
        
        do {
            try pointerScaler?.start()
            logger.info("Pointer scaler started successfully")
        } catch {
            logger.error("Failed to start pointer scaler: \(error.localizedDescription)")
        }
    }
    
    func updatePrecisionFactor(_ factor: Double) {
        precisionFactor = factor
        pointerScaler?.updatePrecisionFactor(factor)
    }
    
    /// Re-check AXIsProcessTrusted() and restart/stop PointerScaler accordingly.
    func refreshPermission() {
        let trusted = AXIsProcessTrusted()
        if trusted != isAccessibilityGranted {
            isAccessibilityGranted = trusted
            logger.debug("Accessibility permission changed. trusted = \(trusted)")
            if trusted {
                setupPointerScaler()
            } else {
                pointerScaler?.stop()
                pointerScaler = nil
            }
        }
    }
    
    deinit {
        pointerScaler?.stop()
    }
}
</file>

<file path="Sources/DragobooCore/PointerScaler.swift">
import Foundation
import CoreGraphics
import ApplicationServices
import os
import Dispatch
import Carbon

public class PointerScaler {
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var precisionFactor: Double
    private var fnKeyPressed = false
    private let logger = Logger(subsystem: "com.dragoboo.core", category: "PointerScaler")
    private var debugTimer: Timer?
    private var eventCount = 0
    private var scaledEventCount = 0
    private var totalEventsReceived = 0
    private var fnEventsReceived = 0
    private var scalingEventsApplied = 0
    
    // FRACTIONAL MOVEMENT ACCUMULATION
    private var accumulatedX: Double = 0.0
    private var accumulatedY: Double = 0.0
    
    public var onPrecisionModeChange: ((Bool) -> Void)?
    
    private static let fnKeyCode: CGKeyCode = 0x3F
    
    public init(precisionFactor: Double) {
        self.precisionFactor = precisionFactor
    }
    
    private func addDiagnostics() {
        // Verify tap is actually enabled
        if let tap = eventTap {
            let isEnabled = CGEvent.tapIsEnabled(tap: tap)
            logger.debug("Event tap enabled status: \(isEnabled)")
        }
        
        // Log secure input status
        let secureInput = IsSecureEventInputEnabled()
        logger.debug("Secure input mode: \(secureInput)")
        
        // Test key state detection
        let fnState = CGEventSource.keyState(.combinedSessionState, key: 0x3F)
        logger.debug("FN key polling state: \(fnState)")
    }
    
    public func start() throws {
        print("PointerScaler: Starting pointer scaler...")
        logger.info("Starting pointer scaler...")
        
        // Check accessibility permissions first
        guard AXIsProcessTrusted() else {
            print("PointerScaler: Accessibility permissions not granted")
            logger.error("Accessibility permissions not granted")
            throw PointerScalerError.failedToCreateEventTap
        }
        print("PointerScaler: Accessibility permissions verified")
        logger.info("Accessibility permissions verified")
        
        // Check for secure input mode which can block event modifications
        checkSecureInputMode()
        
        let eventMask: CGEventMask = (1 << CGEventType.mouseMoved.rawValue) |
                                     (1 << CGEventType.leftMouseDragged.rawValue) |
                                     (1 << CGEventType.rightMouseDragged.rawValue) |
                                     (1 << CGEventType.otherMouseDragged.rawValue) |
                                     (1 << CGEventType.scrollWheel.rawValue) |
                                     (1 << CGEventType.flagsChanged.rawValue) |
                                     (1 << CGEventType.tapDisabledByTimeout.rawValue) |
                                     (1 << CGEventType.tapDisabledByUserInput.rawValue)
        
        let selfPointer = Unmanaged.passUnretained(self).toOpaque()
        
        // Use the main run loop for event tap to ensure proper event capture
        let mainRunLoop = CFRunLoopGetMain()
        
        // TRY DIFFERENT EVENT TAP LOCATION - HID instead of Session
        guard let tap = CGEvent.tapCreate(
            tap: .cgSessionEventTap,  // Back to Session but test double fields
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: eventMask,
            callback: { proxy, type, event, userInfo in
                guard let userInfo = userInfo else { 
                    Logger(subsystem: "com.dragoboo.core", category: "PointerScaler").error("Event callback received nil userInfo")
                    return Unmanaged.passUnretained(event) 
                }
                let scaler = Unmanaged<PointerScaler>.fromOpaque(userInfo).takeUnretainedValue()
                return scaler.handleEvent(proxy: proxy, type: type, event: event)
            },
            userInfo: selfPointer
        ) else {
            logger.error("Event tap FAILED ❌ – likely permission or SecureInput.")
            throw PointerScalerError.failedToCreateEventTap
        }
        
        eventTap = tap
        
        logger.debug("Event tap created ✅ at location=Session")
        
        // Create run loop source and add to main run loop
        guard let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, eventTap!, 0) else {
            logger.error("Failed to create run loop source")
            CGEvent.tapEnable(tap: eventTap!, enable: false)
            CFMachPortInvalidate(eventTap!)
            throw PointerScalerError.failedToCreateEventTap
        }
        
        runLoopSource = source
        
        // Add source to main run loop (critical fix)
        CFRunLoopAddSource(mainRunLoop, source, .commonModes)
        
        // Enable the event tap
        CGEvent.tapEnable(tap: eventTap!, enable: true)
        
        print("PointerScaler: Event tap enabled successfully")
        logger.info("Event tap enabled successfully")
        
        // Run diagnostics after successful setup
        addDiagnostics()
        
        // Start debug timer
        startDebugTimer()
    }
    
    public func stop() {
        debugTimer?.invalidate()
        debugTimer = nil
        
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
            CFMachPortInvalidate(tap)
        }
        
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetMain(), source, .commonModes)
        }
        
        eventTap = nil
        runLoopSource = nil
        logger.info("Event tap stopped")
    }
    
    public func updatePrecisionFactor(_ factor: Double) {
        precisionFactor = factor
        logger.info("Updated precision factor to \(factor)")
    }
    
    private func checkSecureInputMode() {
        // Check if secure input mode is active, which can block event modifications
        if IsSecureEventInputEnabled() {
            logger.warning("Secure input mode is active. This may prevent event modifications from working.")
        } else {
            logger.info("Secure input mode is not active")
        }
    }
    
    private func handleEvent(proxy: CGEventTapProxy, type: CGEventType, event: CGEvent) -> Unmanaged<CGEvent>? {
        // Ensure we're processing events consistently (removed strict main thread check as event taps may run on different threads)
        
        totalEventsReceived += 1
        if totalEventsReceived % 100 == 0 {
            logger.debug("Event stats: total=\(self.totalEventsReceived), fn=\(self.fnEventsReceived), scaled=\(self.scalingEventsApplied)")
        }
        
        self.eventCount += 1
        logger.info("Processing event #\(self.eventCount): \(self.debugEventType(type))")
        
        switch type {
        case .flagsChanged:
            print("PointerScaler: Received flagsChanged event")
            logger.debug("flagsChanged received – flags=\(event.flags.rawValue, privacy: .public)")
            fnEventsReceived += 1
            handleFlagsChanged(event: event)
            
        case .mouseMoved, .leftMouseDragged, .rightMouseDragged, .otherMouseDragged:
            self.totalEventsReceived += 1
            logger.notice("🖱️ MOUSE EVENT #\(self.totalEventsReceived): \(self.debugEventType(type))")
            print("PointerScaler: 🖱️ MOUSE EVENT #\(self.totalEventsReceived): \(self.debugEventType(type))")
            
            self.updateFnKeyState()
            logger.notice("🔑 FN KEY STATE: \(self.fnKeyPressed ? "PRESSED ✅" : "NOT PRESSED ❌")")
            print("PointerScaler: 🔑 FN KEY STATE: \(self.fnKeyPressed ? "PRESSED ✅" : "NOT PRESSED ❌")")
            
            if self.fnKeyPressed {
                logger.notice("🎯 ATTEMPTING TO SCALE MOUSE MOVEMENT...")
                print("PointerScaler: 🎯 ATTEMPTING TO SCALE MOUSE MOVEMENT...")
                let wasScaled = self.scaleMouseMovement(event: event)
                if wasScaled {
                    self.scaledEventCount += 1
                    self.scalingEventsApplied += 1
                    logger.notice("✅ SCALING APPLIED! Total scaled: \(self.scalingEventsApplied)")
                    print("PointerScaler: ✅ SCALING APPLIED! Total scaled: \(self.scalingEventsApplied)")
                } else {
                    logger.error("❌ SCALING FAILED!")
                    print("PointerScaler: ❌ SCALING FAILED!")
                }
            } else {
                logger.notice("⭕ FN KEY NOT PRESSED - NO SCALING")
                print("PointerScaler: ⭕ FN KEY NOT PRESSED - NO SCALING")
            }
            
        case .scrollWheel:
            print("PointerScaler: Received scroll wheel event")
            updateFnKeyState()
            if fnKeyPressed {
                let wasScaled = scaleScrollWheel(event: event)
                if wasScaled {
                    self.scaledEventCount += 1
                    scalingEventsApplied += 1
                    logger.info("Applied scroll scaling with fn key pressed (total scaled: \(self.scaledEventCount))")
                }
            }
            
        case .tapDisabledByTimeout, .tapDisabledByUserInput:
            logger.warning("Event tap disabled by \(type == .tapDisabledByTimeout ? "timeout" : "user input"), attempting to re-enable")
            if let tap = eventTap {
                CGEvent.tapEnable(tap: tap, enable: true)
            }
            return nil  // Return nil for these events
            
        default:
            logger.debug("Received other event type: \(type.rawValue)")
            break
        }
        
        return Unmanaged.passUnretained(event)
    }
    
    private func debugEventType(_ type: CGEventType) -> String {
        switch type {
        case .null: return "null"
        case .leftMouseDown: return "leftMouseDown"
        case .leftMouseUp: return "leftMouseUp"
        case .rightMouseDown: return "rightMouseDown"
        case .rightMouseUp: return "rightMouseUp"
        case .mouseMoved: return "mouseMoved"
        case .leftMouseDragged: return "leftMouseDragged"
        case .rightMouseDragged: return "rightMouseDragged"
        case .keyDown: return "keyDown"
        case .keyUp: return "keyUp"
        case .flagsChanged: return "flagsChanged"
        case .scrollWheel: return "scrollWheel"
        case .tabletPointer: return "tabletPointer"
        case .tabletProximity: return "tabletProximity"
        case .otherMouseDown: return "otherMouseDown"
        case .otherMouseUp: return "otherMouseUp"
        case .otherMouseDragged: return "otherMouseDragged"
        case .tapDisabledByTimeout: return "tapDisabledByTimeout"
        case .tapDisabledByUserInput: return "tapDisabledByUserInput"
        default: return "unknown(\(type.rawValue))"
        }
    }
    
    private func handleFlagsChanged(event: CGEvent) {
        // Check keycode directly (FN key is keycode 63/0x3F)
        let keyCode = event.getIntegerValueField(.keyboardEventKeycode)
        let flags = event.flags
        
        logger.debug("FlagsChanged event: keyCode=\(keyCode), flags=\(flags.rawValue)")
        logger.debug("Flags breakdown: cmd=\(flags.contains(.maskCommand)), opt=\(flags.contains(.maskAlternate)), ctrl=\(flags.contains(.maskControl)), shift=\(flags.contains(.maskShift)), fn=\(flags.contains(.maskSecondaryFn))")
        
        if keyCode == 63 {
            // Fixed: Use actual flag state instead of toggle
            let wasFnPressed = fnKeyPressed
            fnKeyPressed = flags.contains(.maskSecondaryFn)
            
            if wasFnPressed != fnKeyPressed {
                logger.notice("FN key state changed via keycode 63: \(self.fnKeyPressed ? "PRESSED" : "RELEASED")")
                onPrecisionModeChange?(fnKeyPressed)
                
                // Reset accumulation when switching modes
                accumulatedX = 0.0
                accumulatedY = 0.0
                logger.debug("Cleared fractional accumulation on fn key state change (flags)")
            }
            return
        }
        
        // Fallback: Check flag state directly without polling to avoid race conditions
        let wasFnPressed = fnKeyPressed
        fnKeyPressed = flags.contains(.maskSecondaryFn)
        
        if wasFnPressed != fnKeyPressed {
            logger.notice("Fn key state changed via flags: \(self.fnKeyPressed ? "PRESSED" : "RELEASED")")
            onPrecisionModeChange?(fnKeyPressed)
            
            // Reset accumulation when switching modes
            accumulatedX = 0.0
            accumulatedY = 0.0
            logger.debug("Cleared fractional accumulation on fn key state change (flags fallback)")
        }
    }
    
    private func updateFnKeyState() {
        let keyState = CGEventSource.keyState(.combinedSessionState, key: Self.fnKeyCode)
        let wasFnPressed = fnKeyPressed
        
        fnKeyPressed = keyState
        
        if wasFnPressed != fnKeyPressed {
            logger.notice("Fn key state updated via polling: \(self.fnKeyPressed ? "PRESSED" : "RELEASED")")
            onPrecisionModeChange?(fnKeyPressed)
            
            // Reset accumulation when switching modes to prevent jumps
            accumulatedX = 0.0
            accumulatedY = 0.0
            logger.debug("Cleared fractional accumulation on fn key state change")
        }
    }
    
    private func scaleMouseMovement(event: CGEvent) -> Bool {
        logger.notice("🔄 ENTERING scaleMouseMovement function")
        print("PointerScaler: 🔄 ENTERING scaleMouseMovement function")
        
        // TEST ALL FIELD ACCESS METHODS (from TODO.md)
        let deltaX_int = event.getIntegerValueField(.mouseEventDeltaX)
        let deltaY_int = event.getIntegerValueField(.mouseEventDeltaY)
        let deltaX_double = event.getDoubleValueField(.mouseEventDeltaX)
        let deltaY_double = event.getDoubleValueField(.mouseEventDeltaY)
        
        logger.notice("📊 FIELD COMPARISON:")
        logger.notice("   Integer: X=\(deltaX_int), Y=\(deltaY_int)")
        logger.notice("   Double:  X=\(deltaX_double), Y=\(deltaY_double)")
        print("PointerScaler: 📊 FIELD COMPARISON: Integer(\(deltaX_int),\(deltaY_int)) Double(\(deltaX_double),\(deltaY_double))")
        
        guard deltaX_int != 0 || deltaY_int != 0 else {
            logger.notice("⭕ NO MOVEMENT - SKIPPING")
            print("PointerScaler: ⭕ NO MOVEMENT - SKIPPING")
            return false
        }
        
        // EXTREME SCALING FACTOR (from TODO.md) - Make effect super obvious
        let extremeFactor = 20.0  // 20x slower instead of user factor!
        
        // Try DOUBLE FIELDS approach
        let scaledMovementX_double = deltaX_double / extremeFactor
        let scaledMovementY_double = deltaY_double / extremeFactor
        
        logger.notice("🚨 EXTREME SCALING TEST (20x slower):")
        logger.notice("   Original doubles: (\(deltaX_double),\(deltaY_double))")
        logger.notice("   Scaled doubles: (\(scaledMovementX_double),\(scaledMovementY_double))")
        
        // FIRST: Try setting DOUBLE fields directly
        event.setDoubleValueField(.mouseEventDeltaX, value: scaledMovementX_double)
        event.setDoubleValueField(.mouseEventDeltaY, value: scaledMovementY_double)
        
        // Verify double field setting
        let verifyX_double = event.getDoubleValueField(.mouseEventDeltaX)
        let verifyY_double = event.getDoubleValueField(.mouseEventDeltaY)
        
        logger.notice("🔍 DOUBLE FIELD TEST:")
        logger.notice("   Set: (\(scaledMovementX_double),\(scaledMovementY_double))")
        logger.notice("   Got: (\(verifyX_double),\(verifyY_double))")
        
        let doubleSuccess = abs(verifyX_double - scaledMovementX_double) < 0.001 && abs(verifyY_double - scaledMovementY_double) < 0.001
        
        if doubleSuccess {
            logger.notice("✅ DOUBLE FIELDS WORKED!")
            print("PointerScaler: ✅ DOUBLE FIELDS WORKED! Set(\(scaledMovementX_double),\(scaledMovementY_double)) Got(\(verifyX_double),\(verifyY_double))")
        } else {
            logger.warning("❌ DOUBLE FIELDS FAILED - trying integer fallback")
            print("PointerScaler: ❌ DOUBLE FIELDS FAILED")
            
            // FALLBACK: Try integer fields with extreme scaling
            let scaledX_int = Int64(deltaX_double / extremeFactor)
            let scaledY_int = Int64(deltaY_double / extremeFactor)
            
            logger.notice("🔄 INTEGER FALLBACK:")
            logger.notice("   Scaled integers: (\(scaledX_int),\(scaledY_int))")
            
            event.setIntegerValueField(.mouseEventDeltaX, value: scaledX_int)
            event.setIntegerValueField(.mouseEventDeltaY, value: scaledY_int)
            
            let verifyX_int = event.getIntegerValueField(.mouseEventDeltaX)
            let verifyY_int = event.getIntegerValueField(.mouseEventDeltaY)
            
            logger.notice("   Set: (\(scaledX_int),\(scaledY_int))")
            logger.notice("   Got: (\(verifyX_int),\(verifyY_int))")
            
            let intSuccess = verifyX_int == scaledX_int && verifyY_int == scaledY_int
            logger.notice("🎯 INTEGER SCALING \(intSuccess ? "SUCCESS" : "FAILED")")
            print("PointerScaler: 🎯 INTEGER SCALING \(intSuccess ? "SUCCESS" : "FAILED")")
            
            return intSuccess
        }
        
        // Reset instant mouser to prevent WindowServer corrections
        event.setIntegerValueField(.mouseEventInstantMouser, value: 0)
        
        logger.notice("🎯 EXTREME SCALING COMPLETE - 20x SLOWER!")
        print("PointerScaler: 🎯 EXTREME SCALING COMPLETE - 20x SLOWER!")
        
        return doubleSuccess
    }
    
    private func scaleScrollWheel(event: CGEvent) -> Bool {
        // Try integer fields first for scroll wheel deltas
        let deltaAxis1 = event.getIntegerValueField(.scrollWheelEventDeltaAxis1)
        let deltaAxis2 = event.getIntegerValueField(.scrollWheelEventDeltaAxis2)
        
        // Only scale if there's actual scroll movement (non-zero deltas)
        guard deltaAxis1 != 0 || deltaAxis2 != 0 else {
            return false
        }
        
        let scaledDelta1 = Int64(Double(deltaAxis1) / precisionFactor)
        let scaledDelta2 = Int64(Double(deltaAxis2) / precisionFactor)
        
        logger.debug("Scaling scroll: (\(deltaAxis1), \(deltaAxis2)) -> (\(scaledDelta1), \(scaledDelta2)) with factor \(self.precisionFactor)")
        
        event.setIntegerValueField(.scrollWheelEventDeltaAxis1, value: scaledDelta1)
        event.setIntegerValueField(.scrollWheelEventDeltaAxis2, value: scaledDelta2)
        
        // Verify scroll scaling
        let verifyDelta1 = event.getIntegerValueField(.scrollWheelEventDeltaAxis1)
        let verifyDelta2 = event.getIntegerValueField(.scrollWheelEventDeltaAxis2)
        let scrollScalingWorked = verifyDelta1 == scaledDelta1 && verifyDelta2 == scaledDelta2
        
        if !scrollScalingWorked {
            logger.error("CRITICAL: Scroll scaling failed! Expected (\(scaledDelta1), \(scaledDelta2)), got (\(verifyDelta1), \(verifyDelta2))")
        }
        
        return scrollScalingWorked
    }
    
    private func startDebugTimer() {
        debugTimer = Timer.scheduledTimer(withTimeInterval: 10.0, repeats: true) { [weak self] _ in
            self?.debugCurrentState()
        }
    }
    
    private func debugCurrentState() {
        let keyState = CGEventSource.keyState(.combinedSessionState, key: Self.fnKeyCode)
        logger.notice("Debug: fn key polling=\(keyState ? "PRESSED" : "RELEASED"), internal=\(self.fnKeyPressed ? "PRESSED" : "RELEASED"), factor=\(self.precisionFactor)")
        logger.notice("Event stats: total=\(self.eventCount), scaled=\(self.scaledEventCount)")
        
        // Check secure input mode periodically
        if IsSecureEventInputEnabled() {
            logger.warning("Secure input mode is active")
        }
    }
}

public enum PointerScalerError: LocalizedError {
    case failedToCreateEventTap
    
    public var errorDescription: String? {
        switch self {
        case .failedToCreateEventTap:
            return "Failed to create event tap. Please ensure accessibility permissions are granted."
        }
    }
}
</file>

<file path="Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>Dragoboo</string>
    <key>CFBundleIdentifier</key>
    <string>com.dragoboo.app</string>
    <key>CFBundleName</key>
    <string>Dragoboo</string>
    <key>CFBundleDisplayName</key>
    <string>Dragoboo</string>
    <key>CFBundleVersion</key>
    <string>1.0</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>LSMinimumSystemVersion</key>
    <string>13.0</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSPrincipalClass</key>
    <string>NSApplication</string>
    <key>NSHumanReadableCopyright</key>
    <string>Copyright © 2025. All rights reserved.</string>
    <key>NSHighResolutionCapable</key>
    <true/>
    <key>LSApplicationCategoryType</key>
    <string>public.app-category.utilities</string>
</dict>
</plist>
</file>

<file path="Makefile">
.PHONY: all build run clean stop release help

# Default target
all: run

# Build the app
build:
	@./run.sh --no-launch

# Build and run the app
run:
	@./run.sh

# Clean build
clean:
	@echo "Cleaning build directory..."
	@rm -rf .build
	@rm -rf build
	@echo "Clean complete"

# Stop the running app
stop:
	@./stop.sh

# Build release version
release:
	@./run.sh --release

# Build clean
rebuild: clean build

# Show help
help:
	@echo "Dragoboo Makefile"
	@echo "================"
	@echo "Available targets:"
	@echo "  make         - Build and run the app (default)"
	@echo "  make build   - Build the app without running"
	@echo "  make run     - Build and run the app"
	@echo "  make clean   - Clean build directory"
	@echo "  make stop    - Stop the running app"
	@echo "  make release - Build release version"
	@echo "  make rebuild - Clean and rebuild"
	@echo "  make help    - Show this help message"
</file>

<file path="run.sh">
#!/bin/bash

# Dragoboo SPM build and run script
# This script builds and runs the Dragoboo app using Swift Package Manager

set -e # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

# Check if swift is available
if ! command -v swift &>/dev/null; then
    print_error "Swift not found. Please install Xcode or Swift toolchain."
    exit 1
fi

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Configuration
APP_NAME="Dragoboo"
BUILD_DIR=".build"
EXECUTABLE_NAME="Dragoboo"
APP_BUNDLE_DIR="build"
APP_BUNDLE_NAME="Dragoboo.app"

# Parse command line arguments
CLEAN_BUILD=false
RELEASE_BUILD=false
NO_LAUNCH=false

while [[ $# -gt 0 ]]; do
    case $1 in
    --clean)
        CLEAN_BUILD=true
        shift
        ;;
    --release)
        RELEASE_BUILD=true
        shift
        ;;
    --no-launch)
        NO_LAUNCH=true
        shift
        ;;
    --help | -h)
        echo "Usage: $0 [options]"
        echo "Options:"
        echo "  --clean      Clean build directory before building"
        echo "  --release    Build in Release configuration"
        echo "  --no-launch  Build only, don't launch the app"
        echo "  --help       Show this help message"
        exit 0
        ;;
    *)
        print_error "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
    esac
done

# Clean build directory if requested
if [ "$CLEAN_BUILD" = true ]; then
    print_status "Cleaning build directory..."
    rm -rf "$BUILD_DIR"
    rm -rf "$APP_BUNDLE_DIR"
fi

print_status "Building $APP_NAME with Swift Package Manager..."

# Build the project
if [ "$RELEASE_BUILD" = true ]; then
    print_status "Building in Release mode..."
    swift build --configuration release
    EXECUTABLE_PATH="$BUILD_DIR/release/$EXECUTABLE_NAME"
else
    print_status "Building in Debug mode..."
    swift build
    EXECUTABLE_PATH="$BUILD_DIR/debug/$EXECUTABLE_NAME"
fi

# Check if build succeeded
if [ $? -ne 0 ]; then
    print_error "Build failed!"
    exit 1
fi

print_status "Build completed successfully!"

# Check if executable exists
if [ ! -f "$EXECUTABLE_PATH" ]; then
    print_error "Could not find built executable at: $EXECUTABLE_PATH"
    exit 1
fi

print_status "Found executable at: $EXECUTABLE_PATH"

# Create .app bundle
print_status "Creating .app bundle..."
APP_BUNDLE_PATH="$APP_BUNDLE_DIR/$APP_BUNDLE_NAME"
CONTENTS_DIR="$APP_BUNDLE_PATH/Contents"
MACOS_DIR="$CONTENTS_DIR/MacOS"
RESOURCES_DIR="$CONTENTS_DIR/Resources"

# Create bundle directory structure
mkdir -p "$MACOS_DIR"
mkdir -p "$RESOURCES_DIR"

# Copy executable to bundle
cp "$EXECUTABLE_PATH" "$MACOS_DIR/$EXECUTABLE_NAME"
chmod +x "$MACOS_DIR/$EXECUTABLE_NAME"

# Copy Info.plist to bundle
if [ -f "Info.plist" ]; then
    cp "Info.plist" "$CONTENTS_DIR/"
    print_status "Copied Info.plist to bundle"
else
    print_error "Info.plist not found! Please ensure Info.plist exists in the project root."
    exit 1
fi

# Copy Assets.xcassets if it exists in Sources/DragobooApp/
if [ -d "Sources/DragobooApp/Assets.xcassets" ]; then
    cp -r "Sources/DragobooApp/Assets.xcassets" "$RESOURCES_DIR/"
    print_status "Copied Assets.xcassets to bundle"
fi

print_status "App bundle created at: $APP_BUNDLE_PATH"

# Update executable path to point to bundle
EXECUTABLE_PATH="$MACOS_DIR/$EXECUTABLE_NAME"
APP_LAUNCH_PATH="$APP_BUNDLE_PATH"

repomix -o llms.txt -i .specstory,_private,.cursorrules,CLAUDE.md
tree >>llms.txt

# Exit here if --no-launch was specified
if [ "$NO_LAUNCH" = true ]; then
    print_status "Build complete. App bundle location: $APP_BUNDLE_PATH"
    exit 0
fi

# Check if app is already running and kill it
APP_PID=$(pgrep -f "$APP_BUNDLE_NAME" || true)
if [ -n "$APP_PID" ]; then
    print_warning "Dragoboo is already running (PID: $APP_PID). Terminating..."
    kill "$APP_PID" 2>/dev/null || true
    sleep 1
fi

# Check accessibility permissions
print_warning "Note: Dragoboo requires accessibility permissions to function."
print_warning "You may be prompted to grant permissions in System Settings."

# Launch the app bundle
print_status "Launching $APP_NAME from: $APP_BUNDLE_PATH"
open "$APP_BUNDLE_PATH"

# Wait a moment for the app to start
sleep 2

# Check if app is running
if pgrep -f "$APP_BUNDLE_NAME" >/dev/null; then
    print_status "Dragoboo is now running!"
    print_status "Look for the cursor icon in your menu bar"
    print_status "Hold the fn key while moving your trackpad/mouse for precision mode"
    echo ""
    print_warning "To stop Dragoboo: Use ./stop.sh or kill the process"
else
    print_error "Failed to launch Dragoboo"
    exit 1
fi
</file>

<file path="stop.sh">
#!/bin/bash

# Dragoboo stop script
# This script stops the running Dragoboo app

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

EXECUTABLE_NAME="Dragoboo.app"

# Find Dragoboo process
APP_PID=$(pgrep -f "$EXECUTABLE_NAME" || true)

if [ -z "$APP_PID" ]; then
    print_warning "Dragoboo is not running"
    exit 0
fi

print_status "Found Dragoboo running (PID: $APP_PID)"
print_status "Stopping Dragoboo..."

# Try graceful termination first
kill "$APP_PID" 2>/dev/null

# Wait for process to terminate
sleep 1

# Check if still running
if pgrep -f "$EXECUTABLE_NAME" >/dev/null; then
    print_warning "Dragoboo didn't stop gracefully, forcing termination..."
    kill -9 "$APP_PID" 2>/dev/null || true
fi

# Final check
if pgrep -f "$EXECUTABLE_NAME" >/dev/null; then
    print_error "Failed to stop Dragoboo"
    exit 1
else
    print_status "Dragoboo stopped successfully"
fi
</file>

<file path="TODO.md">
# TODO.md - Dragoboo Debugging Plan

## 🚨 CURRENT STATUS - App Builds But Scaling Still Not Working!

✅ **COMPLETED FIXES:**
1. Fixed mouse delta field types (integer vs double) ✅
2. Fixed fn key detection logic (removed toggle behavior) ✅  
3. Fixed scroll wheel field types ✅
4. Added mouseEventInstantMouser reset ✅
5. Event tap configuration verified ✅

❌ **PROBLEM PERSISTS:**
- UI correctly shows "Precision mode active" when fn key is held
- BUT mouse cursor still moves at normal speed (no slowdown)
- Permissions are granted and working
- App builds and runs without errors

## 🔍 PHASE 7: Deep Debugging - Why No Slowdown? 🔴 URGENT

### 7.1 Verify Events Are Being Intercepted
**Goal:** Confirm mouse events are actually reaching our event tap

Add comprehensive logging to `handleEvent`:
```swift
case .mouseMoved, .leftMouseDragged, .rightMouseDragged, .otherMouseDragged:
    logger.notice("🖱️ MOUSE EVENT RECEIVED: type=\(type.rawValue)")
    updateFnKeyState()
    if fnKeyPressed {
        logger.notice("🎯 FN KEY IS PRESSED - SHOULD SCALE NOW")
        let wasScaled = scaleMouseMovement(event: event)
        logger.notice("📊 SCALING RESULT: \(wasScaled ? "SUCCESS" : "FAILED")")
        // ... rest
    } else {
        logger.notice("⭕ FN KEY NOT PRESSED - NO SCALING")
    }
```

### 7.2 Verify Delta Values Are Non-Zero
**Goal:** Check if we're getting actual movement deltas

In `scaleMouseMovement`, add before the guard:
```swift
let deltaX = event.getIntegerValueField(.mouseEventDeltaX)
let deltaY = event.getIntegerValueField(.mouseEventDeltaY)
logger.notice("🔢 RAW DELTAS: X=\(deltaX), Y=\(deltaY)")
```

### 7.3 Test with Extreme Scaling Factor
**Goal:** Make scaling so obvious it can't be missed

Temporarily hard-code extreme scaling:
```swift
// TEMP DEBUG: Make scaling super obvious
let scaledDeltaX = Int64(deltaX / 20)  // 20x slower!
let scaledDeltaY = Int64(deltaY / 20)
logger.notice("🐌 EXTREME SCALING: (\(deltaX),\(deltaY)) -> (\(scaledDeltaX),\(scaledDeltaY))")
```

### 7.4 Test Different Field Access Methods
**Goal:** Try all possible ways to access/set mouse deltas

Add fallback attempts:
```swift
// Try different field access methods
logger.debug("Testing field access methods...")

// Method 1: Current (integer)
let deltaX_int = event.getIntegerValueField(.mouseEventDeltaX)
logger.debug("Integer method: X=\(deltaX_int)")

// Method 2: Try double (maybe it's actually double?)
let deltaX_double = event.getDoubleValueField(.mouseEventDeltaX)
logger.debug("Double method: X=\(deltaX_double)")

// Method 3: Test setting and immediate verification
event.setIntegerValueField(.mouseEventDeltaX, value: 1)
let verify1 = event.getIntegerValueField(.mouseEventDeltaX)
logger.debug("Set 1 (int) -> verify: \(verify1)")

event.setDoubleValueField(.mouseEventDeltaX, value: 2.0)
let verify2 = event.getDoubleValueField(.mouseEventDeltaX)
logger.debug("Set 2.0 (double) -> verify: \(verify2)")
```

### 7.5 Check Event Tap Priority/Order
**Goal:** Ensure our tap runs before system processing

Try different tap locations:
```swift
// Test with different tap location
guard let tap = CGEvent.tapCreate(
    tap: .cgHIDEventTap,           // Try HID instead of session
    place: .headInsertEventTap,    // Try different insertion points
    options: .defaultTap,          // Confirm not .listenOnly
    // ...
)
```

### 7.6 Console Log Analysis
**Goal:** Watch real-time debug output

Check Console.app for our debug messages:
1. Open Console.app
2. Filter for "com.dragoboo.core" 
3. Watch for mouse event messages while testing
4. Look for any ERROR or WARNING messages

### 7.7 Test with System Mouse Tools
**Goal:** Verify event modification is possible at all

Test if other mouse utilities work on your system:
- Download a known working mouse utility
- See if THOSE can modify mouse speed
- This confirms if system-level mouse modification is blocked

## 🔧 DEBUGGING IMPLEMENTATION PLAN

### Step 1: Add Enhanced Logging (HIGH PRIORITY)
```swift
// In handleEvent, replace mouse handling with:
case .mouseMoved, .leftMouseDragged, .rightMouseDragged, .otherMouseDragged:
    totalEventsReceived += 1
    logger.notice("🖱️ MOUSE EVENT #\(totalEventsReceived): \(debugEventType(type))")
    
    updateFnKeyState()
    logger.notice("🔑 FN KEY STATE: \(fnKeyPressed ? "PRESSED ✅" : "NOT PRESSED ❌")")
    
    if fnKeyPressed {
        logger.notice("🎯 ATTEMPTING TO SCALE MOUSE MOVEMENT...")
        let wasScaled = scaleMouseMovement(event: event)
        if wasScaled {
            scalingEventsApplied += 1
            logger.notice("✅ SCALING APPLIED! Total scaled: \(scalingEventsApplied)")
        } else {
            logger.error("❌ SCALING FAILED!")
        }
    }
```

### Step 2: Extreme Debug in scaleMouseMovement
```swift
private func scaleMouseMovement(event: CGEvent) -> Bool {
    logger.notice("🔄 ENTERING scaleMouseMovement function")
    
    // Test all field access methods
    let deltaX_int = event.getIntegerValueField(.mouseEventDeltaX)
    let deltaY_int = event.getIntegerValueField(.mouseEventDeltaY)
    let deltaX_double = event.getDoubleValueField(.mouseEventDeltaX)
    let deltaY_double = event.getDoubleValueField(.mouseEventDeltaY)
    
    logger.notice("📊 FIELD COMPARISON:")
    logger.notice("   Integer: X=\(deltaX_int), Y=\(deltaY_int)")
    logger.notice("   Double:  X=\(deltaX_double), Y=\(deltaY_double)")
    
    guard deltaX_int != 0 || deltaY_int != 0 else {
        logger.notice("⭕ NO MOVEMENT - SKIPPING")
        return false
    }
    
    // Use extreme scaling for testing
    let factor = 10.0  // Make it super obvious
    let scaledX = Int64(Double(deltaX_int) / factor)
    let scaledY = Int64(Double(deltaY_int) / factor) 
    
    logger.notice("🧮 SCALING: (\(deltaX_int),\(deltaY_int)) ÷ \(factor) = (\(scaledX),\(scaledY))")
    
    // Try both field types when setting
    event.setIntegerValueField(.mouseEventDeltaX, value: scaledX)
    event.setIntegerValueField(.mouseEventDeltaY, value: scaledY)
    
    // Immediate verification
    let verifyX = event.getIntegerValueField(.mouseEventDeltaX)
    let verifyY = event.getIntegerValueField(.mouseEventDeltaY)
    
    logger.notice("✅ VERIFICATION: Set (\(scaledX),\(scaledY)) -> Got (\(verifyX),\(verifyY))")
    
    let success = (verifyX == scaledX && verifyY == scaledY)
    logger.notice("🎯 SCALING \(success ? "SUCCESS" : "FAILED")")
    
    return success
}
```

### Step 3: Console Monitoring
1. Open Console.app
2. Filter for "dragoboo" or "com.dragoboo.core"
3. Hold fn key and move mouse slowly
4. Watch for our debug messages
5. Report exactly what messages appear (or don't appear)

## 🧪 TEST SCENARIOS

### Test 1: Verify Event Reception
- Move mouse normally (without fn) → Should see mouse events logged
- Hold fn and move mouse → Should see "FN KEY PRESSED" messages

### Test 2: Verify Delta Values  
- Check if deltas are non-zero in integer vs double fields
- Move mouse in large movements to get bigger deltas

### Test 3: Verify Scaling Math
- Use factor of 10 to make changes obvious
- Check that (10,10) becomes (1,1) with 10x scaling

### Test 4: System Integration
- Test in different apps (TextEdit, Finder, System Settings)
- Try trackpad vs external mouse
- Try different fn key + trackpad settings in System Settings

## 🎯 SUCCESS CRITERIA

After implementing enhanced logging, we should see:
1. Mouse events being received ✅
2. Fn key state correctly detected ✅  
3. Non-zero delta values ✅
4. Successful scaling math ✅
5. Delta values successfully modified ✅
6. **ACTUAL CURSOR SLOWDOWN** ← This is what's missing!

If all above work but cursor still doesn't slow down, then the issue is that our modified events aren't being processed by the system, which points to:
- Event tap priority/ordering issues
- System security blocking event modification
- Wrong event field being modified
- macOS version compatibility issues

## 📋 NEXT STEPS

1. **IMMEDIATE**: Add the enhanced logging above
2. **TEST**: Run app and monitor Console.app output  
3. **ANALYZE**: Report exactly what debug messages appear
4. **ITERATE**: Based on console output, identify the exact failure point
5. **FIX**: Target the specific issue preventing cursor slowdown
</file>

<file path=".gitignore">
# Xcode
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata/
*.xccheckout
*.moved-aside
DerivedData/
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace/
.swiftpm/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Swift Package Manager
.build/
Package.resolved

# CocoaPods
Pods/

# Carthage
Carthage/Build/

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
iOSInjectionProject/
</file>

</files>
.
├── _private
│   └── research.md
├── build
│   └── Dragoboo.app
│       └── Contents
│           ├── Info.plist
│           ├── MacOS
│           │   └── Dragoboo
│           └── Resources
│               └── Assets.xcassets
│                   ├── AppIcon.appiconset
│                   └── Contents.json
├── CLAUDE.md
├── dragoboo_console.log
├── dragoboo_output.log
├── Info.plist
├── llms.txt
├── Makefile
├── Package.swift
├── PLAN.md
├── README.md
├── run.sh
├── somelog.txt
├── Sources
│   ├── DragobooApp
│   │   ├── Assets.xcassets
│   │   │   ├── AppIcon.appiconset
│   │   │   └── Contents.json
│   │   ├── ContentView.swift
│   │   └── DragobooApp.swift
│   └── DragobooCore
│       └── PointerScaler.swift
├── stop.sh
├── Tests
│   └── DragobooCoreTests
│       └── PointerScalerTests.swift
└── TODO.md

16 directories, 22 files
