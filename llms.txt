This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory, _private, .cursorrules, CLAUDE.md
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.cursor/
  rules/
    alignment-algorithms.mdc
    engine-implementations.mdc
    frame-models.mdc
    video-processing-flow.mdc
.giga/
  specifications.json
Sources/
  DragobooApp/
    Assets.xcassets/
      Contents.json
    ContentView.swift
    DragobooApp.swift
  DragobooCore/
    PointerScaler.swift
Tests/
  DragobooCoreTests/
    PointerScalerTests.swift
.cursorindexingignore
.gitignore
Info.plist
Makefile
Package.swift
PLAN.md
README.md
run.sh
stop.sh
TODO.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "enableAllProjectMcpServers": false
}
</file>

<file path=".cursor/rules/alignment-algorithms.mdc">
---
description: Technical documentation for motion scaling algorithms and pointer event handling in precision mode
globs: Sources/DragobooCore/PointerScaler.swift,Dragoboo/DragobooApp.swift
alwaysApply: false
---


# alignment-algorithms

## Core Motion Scaling Algorithm
The pointer scaling system uses a dynamic motion adjustment algorithm that operates by intercepting and modifying system pointer events when precision mode is active:

1. Event Tap Creation:
- Establishes event tap at `.cgSessionEventTap` using `CGEvent.tapCreate`
- Placed at `.headInsertEventTap` priority level
- Monitors specific event types: `mouseMoved`, `leftMouseDragged`, `rightMouseDragged`, `otherMouseDragged`, `scrollWheel`, `flagsChanged`

2. Delta Value Modification:
- Retrieves delta values from mouse/scroll events
- Scales movement by dividing deltas by the precision factor
- Writes modified values back to event using `setDoubleValueField`

3. Fn Key Detection Logic:
- Primary: Checks event flags for `.maskSecondaryFn`
- Fallback: Polls key state using `CGEventSource.keyState(.combinedSessionState, key: 0x3F)`

## Component Architecture

### PointerScaler (Sources/DragobooCore/PointerScaler.swift)
Importance Score: 95
- Handles core event interception and scaling logic
- Creates and manages event tap lifecycle
- Implements precision factor application
- Provides callbacks for precision mode state changes

### AppState (Dragoboo/DragobooApp.swift) 
Importance Score: 85
- Manages precision mode activation state
- Handles precision factor persistence
- Bridges core scaling logic with UI feedback

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga alignment-algorithms".
</file>

<file path=".cursor/rules/engine-implementations.mdc">
---
description: Documents the core temporal alignment engines, their implementations and specialized optimizations for precision cursor control
globs: Sources/DragobooCore/PointerScaler.swift,Dragoboo/DragobooApp.swift
alwaysApply: false
---


# engine-implementations

The engine implementations focus on two core components that handle temporal alignment for cursor precision control:

## Full Engine (Importance: 95)
Located in `Sources/DragobooCore/PointerScaler.swift`, the Full Engine handles:

- Event tap creation at `.cgSessionEventTap` level for global event interception
- Delta value scaling for mouse movements and scroll events based on precision factor
- Real-time fn key state detection through dual methods:
  - Primary: Event flags checking for .maskSecondaryFn
  - Secondary: Key state polling via CGEventSource
- Event modification pipeline for scaled cursor movement

## Mask Engine (Importance: 90)
Located in `Dragoboo/DragobooApp.swift`, the Mask Engine manages:

- Precision mode state tracking and transitions
- Event filtering based on fn key state
- Temporal alignment between user input and cursor response
- Dynamic precision factor application

## Integration Points (Importance: 85)

The engines communicate through:
- Direct event tap callbacks from Full to Mask engine
- State synchronization for precision mode activation
- Delta value transformations based on current precision factor
- Event pipeline coordination for seamless cursor control

## Event Types Handled
Both engines process:
- mouseMoved
- leftMouseDragged
- rightMouseDragged
- otherMouseDragged  
- scrollWheel
- flagsChanged

The dual-engine architecture ensures reliable temporal alignment between user input and cursor response while maintaining system-wide event handling capabilities.

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga engine-implementations".
</file>

<file path=".cursor/rules/frame-models.mdc">
---
description: Core data models and frame structures for video processing pipeline
globs: **/*.swift,**/*.h,**/*.m
alwaysApply: false
---


# frame-models

After reviewing the provided specification, there appears to be no explicit frame-models or video processing pipeline data structures documented in the source material. The specification describes a mouse/trackpad precision control utility (Dragoboo) and does not contain any video frame processing or related data models.

The closest related data structures are:

- Event handling models in `PointerScaler.swift` for processing mouse/trackpad input events
- State management in `AppState` for tracking precision mode status
- UI models in `ContentView.swift` for displaying the menu bar interface

However, these are not frame or video processing related models.

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga frame-models".
</file>

<file path=".cursor/rules/video-processing-flow.mdc">
---
description: Documents video processing flows and media handling pipelines
globs: 
alwaysApply: false
---


# video-processing-flow

After reviewing the provided specification, there are no video processing or media handling flows documented in this project. The specification describes a mouse/trackpad cursor precision control utility (Dragoboo) without any video or media processing capabilities.

$END$

 If you're using this file in context, clearly say in italics in one small line that "Context added by Giga video-processing-flow".
</file>

<file path=".giga/specifications.json">
[
  {
    "fileName": "main-overview.mdc",
    "description": "Complete system overview describing the video overlay and synchronization architecture, key components, and their interactions"
  },
  {
    "fileName": "alignment-algorithms.mdc",
    "description": "Detailed documentation of the three core algorithms: Frame Fingerprinting, Spatial Alignment, and Temporal Alignment Engines, including implementation details and optimizations"
  },
  {
    "fileName": "video-processing-flow.mdc",
    "description": "Comprehensive documentation of the video processing pipeline, data flow between components, and how the various alignment algorithms work together during composition"
  },
  {
    "fileName": "frame-models.mdc",
    "description": "Documentation of core data models including FrameFingerprint, FrameAlignment, and related structures used throughout the video processing pipeline"
  },
  {
    "fileName": "engine-implementations.mdc",
    "description": "Detailed implementation documentation for the Full and Mask temporal alignment engines, including their unique approaches and optimizations"
  }
]
</file>

<file path="Sources/DragobooApp/Assets.xcassets/Contents.json">
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}
</file>

<file path="Sources/DragobooApp/ContentView.swift">
import SwiftUI

struct ContentView: View {
    @EnvironmentObject var appState: AppState
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack(spacing: 20) {
            if !appState.isAccessibilityGranted {
                AccessibilityRequestView()
            } else {
                PrecisionSettingsView()
            }
            
            Divider()
            
            HStack {
                Button("Quit") {
                    NSApplication.shared.terminate(nil)
                }
                .keyboardShortcut("q", modifiers: .command)
                
                Spacer()
                
                if appState.isAccessibilityGranted {
                    StatusIndicator()
                }
            }
        }
        .onAppear { 
            appState.refreshPermission() 
        }
        .padding()
        .frame(width: 300)
    }
}

struct AccessibilityRequestView: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        VStack(spacing: 12) {
            Image(systemName: "lock.shield")
                .font(.system(size: 48))
                .foregroundColor(.orange)
            
            Text("Accessibility Permission Required")
                .font(.headline)
            
            Text("Dragoboo needs accessibility permissions to modify cursor movement.")
                .font(.caption)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)
            
            Button("Grant Permission") {
                appState.requestAccessibility()
            }
            .controlSize(.large)
        }
    }
}

struct PrecisionSettingsView: View {
    @EnvironmentObject var appState: AppState
    @State private var sliderValue: Double = 4.0
    
    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("Precision Settings")
                .font(.headline)
            
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Text("Slowdown Factor:")
                    Spacer()
                    Text("\(Int(sliderValue))×")
                        .monospacedDigit()
                        .foregroundColor(.secondary)
                }
                
                Slider(value: $sliderValue, in: 1...10, step: 1) { _ in
                    appState.updatePrecisionFactor(sliderValue)
                }
                .onAppear {
                    sliderValue = appState.precisionFactor
                }
            }
            
            VStack(alignment: .leading, spacing: 4) {
                Label("Hold fn key to activate precision mode", systemImage: "keyboard")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Label(
                    appState.isPrecisionModeActive ? "Precision mode active" : " ",
                    systemImage: appState.isPrecisionModeActive ? "checkmark.circle.fill" : "circle"
                )
                .font(.caption)
                .foregroundColor(appState.isPrecisionModeActive ? .green : .clear)
            }
        }
    }
}

struct StatusIndicator: View {
    @EnvironmentObject var appState: AppState
    
    var body: some View {
        HStack(spacing: 4) {
            Circle()
                .fill(appState.isPrecisionModeActive ? Color.green : Color.gray)
                .frame(width: 8, height: 8)
            
            Text(appState.isPrecisionModeActive ? "Active" : "Ready")
                .font(.caption)
                .foregroundColor(.secondary)
        }
    }
}

#Preview {
    ContentView()
        .environmentObject(AppState())
}
</file>

<file path="Sources/DragobooApp/DragobooApp.swift">
import SwiftUI
import DragobooCore
import os

@main
struct DragobooApp: App {
    @StateObject private var appState = AppState()
    private let logger = Logger(subsystem: "com.dragoboo.app", category: "main")
    
    var body: some Scene {
        MenuBarExtra("Dragoboo", systemImage: "cursorarrow") {
            ContentView()
                .environmentObject(appState)
        }
        .menuBarExtraStyle(.window)
    }
}

class AppState: ObservableObject {
    @Published var isPrecisionModeActive = false
    @Published var isAccessibilityGranted = false
    @AppStorage("precisionFactor") var precisionFactor: Double = 4.0
    
    private var pointerScaler: PointerScaler?
    private let logger = Logger(subsystem: "com.dragoboo.app", category: "AppState")
    
    init() {
        checkAccessibility()
        setupPointerScaler()
    }
    
    private func checkAccessibility() {
        isAccessibilityGranted = AXIsProcessTrusted()
    }
    
    func requestAccessibility() {
        let options: NSDictionary = [kAXTrustedCheckOptionPrompt.takeUnretainedValue() as String: true]
        isAccessibilityGranted = AXIsProcessTrustedWithOptions(options)
        
        if isAccessibilityGranted {
            setupPointerScaler()
        }
    }
    
    private func setupPointerScaler() {
        guard isAccessibilityGranted else { return }
        
        pointerScaler = PointerScaler(precisionFactor: precisionFactor)
        pointerScaler?.onPrecisionModeChange = { [weak self] isActive in
            DispatchQueue.main.async {
                self?.isPrecisionModeActive = isActive
            }
        }
        
        do {
            try pointerScaler?.start()
            logger.info("Pointer scaler started successfully")
        } catch {
            logger.error("Failed to start pointer scaler: \(error.localizedDescription)")
        }
    }
    
    func updatePrecisionFactor(_ factor: Double) {
        precisionFactor = factor
        pointerScaler?.updatePrecisionFactor(factor)
    }
    
    /// Re-check AXIsProcessTrusted() and restart/stop PointerScaler accordingly.
    func refreshPermission() {
        let trusted = AXIsProcessTrusted()
        if trusted != isAccessibilityGranted {
            isAccessibilityGranted = trusted
            logger.debug("Accessibility permission changed. trusted = \(trusted)")
            if trusted {
                setupPointerScaler()
            } else {
                pointerScaler?.stop()
                pointerScaler = nil
            }
        }
    }
    
    deinit {
        pointerScaler?.stop()
    }
}
</file>

<file path="Sources/DragobooCore/PointerScaler.swift">
import Foundation
import CoreGraphics
import ApplicationServices
import os
import Dispatch
import Carbon

public class PointerScaler {
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var precisionFactor: Double
    private var fnKeyPressed = false
    private let logger = Logger(subsystem: "com.dragoboo.core", category: "PointerScaler")
    private var debugTimer: Timer?
    private var eventCount = 0
    private var scaledEventCount = 0
    private var totalEventsReceived = 0
    private var fnEventsReceived = 0
    private var scalingEventsApplied = 0
    
    public var onPrecisionModeChange: ((Bool) -> Void)?
    
    private static let fnKeyCode: CGKeyCode = 0x3F
    
    public init(precisionFactor: Double) {
        self.precisionFactor = precisionFactor
    }
    
    private func addDiagnostics() {
        // Verify tap is actually enabled
        if let tap = eventTap {
            let isEnabled = CGEvent.tapIsEnabled(tap: tap)
            logger.debug("Event tap enabled status: \(isEnabled)")
        }
        
        // Log secure input status
        let secureInput = IsSecureEventInputEnabled()
        logger.debug("Secure input mode: \(secureInput)")
        
        // Test key state detection
        let fnState = CGEventSource.keyState(.combinedSessionState, key: 0x3F)
        logger.debug("FN key polling state: \(fnState)")
    }
    
    public func start() throws {
        print("PointerScaler: Starting pointer scaler...")
        logger.info("Starting pointer scaler...")
        
        // Check accessibility permissions first
        guard AXIsProcessTrusted() else {
            print("PointerScaler: Accessibility permissions not granted")
            logger.error("Accessibility permissions not granted")
            throw PointerScalerError.failedToCreateEventTap
        }
        print("PointerScaler: Accessibility permissions verified")
        logger.info("Accessibility permissions verified")
        
        // Check for secure input mode which can block event modifications
        checkSecureInputMode()
        
        let eventMask: CGEventMask = (1 << CGEventType.mouseMoved.rawValue) |
                                     (1 << CGEventType.leftMouseDragged.rawValue) |
                                     (1 << CGEventType.rightMouseDragged.rawValue) |
                                     (1 << CGEventType.otherMouseDragged.rawValue) |
                                     (1 << CGEventType.scrollWheel.rawValue) |
                                     (1 << CGEventType.flagsChanged.rawValue) |
                                     (1 << CGEventType.tapDisabledByTimeout.rawValue) |
                                     (1 << CGEventType.tapDisabledByUserInput.rawValue)
        
        let selfPointer = Unmanaged.passUnretained(self).toOpaque()
        
        // Use the main run loop for event tap to ensure proper event capture
        let mainRunLoop = CFRunLoopGetMain()
        
        // Create event tap with session event tap location
        guard let tap = CGEvent.tapCreate(
            tap: .cgSessionEventTap,
            place: .headInsertEventTap,
            options: .defaultTap,
            eventsOfInterest: eventMask,
            callback: { proxy, type, event, userInfo in
                guard let userInfo = userInfo else { 
                    Logger(subsystem: "com.dragoboo.core", category: "PointerScaler").error("Event callback received nil userInfo")
                    return Unmanaged.passUnretained(event) 
                }
                let scaler = Unmanaged<PointerScaler>.fromOpaque(userInfo).takeUnretainedValue()
                return scaler.handleEvent(proxy: proxy, type: type, event: event)
            },
            userInfo: selfPointer
        ) else {
            logger.error("Event tap FAILED ❌ – likely permission or SecureInput.")
            throw PointerScalerError.failedToCreateEventTap
        }
        
        logger.debug("Event tap created ✅ at location=\(CGEventTapLocation.cgSessionEventTap.rawValue)")
        
        // Create run loop source and add to main run loop
        guard let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0) else {
            logger.error("Failed to create run loop source")
            CGEvent.tapEnable(tap: tap, enable: false)
            CFMachPortInvalidate(tap)
            throw PointerScalerError.failedToCreateEventTap
        }
        
        eventTap = tap
        runLoopSource = source
        
        // Add source to main run loop (critical fix)
        CFRunLoopAddSource(mainRunLoop, source, .commonModes)
        
        // Enable the event tap
        CGEvent.tapEnable(tap: tap, enable: true)
        
        print("PointerScaler: Event tap enabled successfully")
        logger.info("Event tap enabled successfully")
        
        // Run diagnostics after successful setup
        addDiagnostics()
        
        // Start debug timer
        startDebugTimer()
    }
    
    public func stop() {
        debugTimer?.invalidate()
        debugTimer = nil
        
        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
            CFMachPortInvalidate(tap)
        }
        
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetMain(), source, .commonModes)
        }
        
        eventTap = nil
        runLoopSource = nil
        logger.info("Event tap stopped")
    }
    
    public func updatePrecisionFactor(_ factor: Double) {
        precisionFactor = factor
        logger.info("Updated precision factor to \(factor)")
    }
    
    private func checkSecureInputMode() {
        // Check if secure input mode is active, which can block event modifications
        if IsSecureEventInputEnabled() {
            logger.warning("Secure input mode is active. This may prevent event modifications from working.")
        } else {
            logger.info("Secure input mode is not active")
        }
    }
    
    private func handleEvent(proxy: CGEventTapProxy, type: CGEventType, event: CGEvent) -> Unmanaged<CGEvent>? {
        // Ensure we're processing events consistently (removed strict main thread check as event taps may run on different threads)
        
        totalEventsReceived += 1
        if totalEventsReceived % 100 == 0 {
            logger.debug("Event stats: total=\(self.totalEventsReceived), fn=\(self.fnEventsReceived), scaled=\(self.scalingEventsApplied)")
        }
        
        self.eventCount += 1
        logger.info("Processing event #\(self.eventCount): \(self.debugEventType(type))")
        
        switch type {
        case .flagsChanged:
            print("PointerScaler: Received flagsChanged event")
            logger.debug("flagsChanged received – flags=\(event.flags.rawValue, privacy: .public)")
            fnEventsReceived += 1
            handleFlagsChanged(event: event)
            
        case .mouseMoved, .leftMouseDragged, .rightMouseDragged, .otherMouseDragged:
            print("PointerScaler: Received mouse movement event")
            updateFnKeyState()
            if fnKeyPressed {
                print("PointerScaler: fn key is pressed, scaling mouse movement")
                let wasScaled = scaleMouseMovement(event: event)
                if wasScaled {
                    self.scaledEventCount += 1
                    scalingEventsApplied += 1
                    print("PointerScaler: Applied mouse scaling with fn key pressed (total scaled: \(self.scaledEventCount))")
                    logger.info("Applied mouse scaling with fn key pressed (total scaled: \(self.scaledEventCount))")
                }
            }
            
        case .scrollWheel:
            print("PointerScaler: Received scroll wheel event")
            updateFnKeyState()
            if fnKeyPressed {
                let wasScaled = scaleScrollWheel(event: event)
                if wasScaled {
                    self.scaledEventCount += 1
                    scalingEventsApplied += 1
                    logger.info("Applied scroll scaling with fn key pressed (total scaled: \(self.scaledEventCount))")
                }
            }
            
        case .tapDisabledByTimeout, .tapDisabledByUserInput:
            logger.warning("Event tap disabled by \(type == .tapDisabledByTimeout ? "timeout" : "user input"), attempting to re-enable")
            if let tap = eventTap {
                CGEvent.tapEnable(tap: tap, enable: true)
            }
            return nil  // Return nil for these events
            
        default:
            logger.debug("Received other event type: \(type.rawValue)")
            break
        }
        
        return Unmanaged.passUnretained(event)
    }
    
    private func debugEventType(_ type: CGEventType) -> String {
        switch type {
        case .null: return "null"
        case .leftMouseDown: return "leftMouseDown"
        case .leftMouseUp: return "leftMouseUp"
        case .rightMouseDown: return "rightMouseDown"
        case .rightMouseUp: return "rightMouseUp"
        case .mouseMoved: return "mouseMoved"
        case .leftMouseDragged: return "leftMouseDragged"
        case .rightMouseDragged: return "rightMouseDragged"
        case .keyDown: return "keyDown"
        case .keyUp: return "keyUp"
        case .flagsChanged: return "flagsChanged"
        case .scrollWheel: return "scrollWheel"
        case .tabletPointer: return "tabletPointer"
        case .tabletProximity: return "tabletProximity"
        case .otherMouseDown: return "otherMouseDown"
        case .otherMouseUp: return "otherMouseUp"
        case .otherMouseDragged: return "otherMouseDragged"
        case .tapDisabledByTimeout: return "tapDisabledByTimeout"
        case .tapDisabledByUserInput: return "tapDisabledByUserInput"
        default: return "unknown(\(type.rawValue))"
        }
    }
    
    private func handleFlagsChanged(event: CGEvent) {
        // Method 1: Check keycode directly (FN key is keycode 63/0x3F)
        let keyCode = event.getIntegerValueField(.keyboardEventKeycode)
        let flags = event.flags
        
        logger.debug("FlagsChanged event: keyCode=\(keyCode), flags=\(flags.rawValue)")
        logger.debug("Flags breakdown: cmd=\(flags.contains(.maskCommand)), opt=\(flags.contains(.maskAlternate)), ctrl=\(flags.contains(.maskControl)), shift=\(flags.contains(.maskShift)), fn=\(flags.contains(.maskSecondaryFn))")
        
        if keyCode == 63 {
            fnKeyPressed = !fnKeyPressed  // Toggle state
            logger.notice("FN key toggled via keycode 63: \(self.fnKeyPressed ? "PRESSED" : "RELEASED")")
            onPrecisionModeChange?(fnKeyPressed)
            return
        }
        
        // Method 2: Enhanced fallback with both flags and polling
        let wasFnPressed = fnKeyPressed
        
        // Use combined detection method
        let fnDown = flags.contains(.maskSecondaryFn) || CGEventSource.keyState(.combinedSessionState, key: 0x3F)
        
        fnKeyPressed = fnDown
        
        if wasFnPressed != fnKeyPressed {
            logger.notice("Fn key state changed via flags/polling: \(self.fnKeyPressed ? "PRESSED" : "RELEASED") (flags=\(flags.contains(.maskSecondaryFn)), polling=\(CGEventSource.keyState(.combinedSessionState, key: 0x3F)))")
            onPrecisionModeChange?(fnKeyPressed)
        }
    }
    
    private func updateFnKeyState() {
        let keyState = CGEventSource.keyState(.combinedSessionState, key: Self.fnKeyCode)
        let wasFnPressed = fnKeyPressed
        
        fnKeyPressed = keyState
        
        if wasFnPressed != fnKeyPressed {
            logger.notice("Fn key state updated via polling: \(self.fnKeyPressed ? "PRESSED" : "RELEASED")")
            onPrecisionModeChange?(fnKeyPressed)
        }
    }
    
    private func scaleMouseMovement(event: CGEvent) -> Bool {
        // Use the correct field constants as suggested by expert analysis
        let deltaX = event.getDoubleValueField(.mouseEventDeltaX)
        let deltaY = event.getDoubleValueField(.mouseEventDeltaY)
        
        // Only scale if there's actual movement (non-zero deltas)
        guard deltaX != 0.0 || deltaY != 0.0 else {
            logger.debug("Skipping scaling - no movement deltas")
            return false
        }
        
        logger.debug("Original deltas: X=\(deltaX), Y=\(deltaY), Factor=\(self.precisionFactor)")
        
        let scaledDeltaX = deltaX / precisionFactor
        let scaledDeltaY = deltaY / precisionFactor
        
        // Set the scaled values using the correct field constants
        event.setDoubleValueField(.mouseEventDeltaX, value: scaledDeltaX)
        event.setDoubleValueField(.mouseEventDeltaY, value: scaledDeltaY)
        
        // Verify the values were actually set (critical verification step)
        let verifyX = event.getDoubleValueField(.mouseEventDeltaX)
        let verifyY = event.getDoubleValueField(.mouseEventDeltaY)
        logger.debug("Scaled deltas applied: X=\(verifyX), Y=\(verifyY)")
        
        // Additional verification that the scaling actually took effect
        let scalingWorked = abs(verifyX - scaledDeltaX) < 0.001 && abs(verifyY - scaledDeltaY) < 0.001
        if !scalingWorked {
            logger.error("CRITICAL: Delta scaling failed! Expected X=\(scaledDeltaX), Y=\(scaledDeltaY), but got X=\(verifyX), Y=\(verifyY)")
        } else {
            logger.debug("Delta scaling verified successful")
        }
        
        return scalingWorked
    }
    
    private func scaleScrollWheel(event: CGEvent) -> Bool {
        let deltaAxis1 = event.getDoubleValueField(.scrollWheelEventDeltaAxis1)
        let deltaAxis2 = event.getDoubleValueField(.scrollWheelEventDeltaAxis2)
        
        // Only scale if there's actual scroll movement (non-zero deltas)
        guard deltaAxis1 != 0.0 || deltaAxis2 != 0.0 else {
            return false
        }
        
        let scaledDelta1 = deltaAxis1 / precisionFactor
        let scaledDelta2 = deltaAxis2 / precisionFactor
        
        logger.debug("Scaling scroll: (\(deltaAxis1), \(deltaAxis2)) -> (\(scaledDelta1), \(scaledDelta2)) with factor \(self.precisionFactor)")
        
        event.setDoubleValueField(.scrollWheelEventDeltaAxis1, value: scaledDelta1)
        event.setDoubleValueField(.scrollWheelEventDeltaAxis2, value: scaledDelta2)
        
        // Verify scroll scaling
        let verifyDelta1 = event.getDoubleValueField(.scrollWheelEventDeltaAxis1)
        let verifyDelta2 = event.getDoubleValueField(.scrollWheelEventDeltaAxis2)
        let scrollScalingWorked = abs(verifyDelta1 - scaledDelta1) < 0.001 && abs(verifyDelta2 - scaledDelta2) < 0.001
        
        if !scrollScalingWorked {
            logger.error("CRITICAL: Scroll scaling failed!")
        }
        
        return scrollScalingWorked
    }
    
    private func startDebugTimer() {
        debugTimer = Timer.scheduledTimer(withTimeInterval: 10.0, repeats: true) { [weak self] _ in
            self?.debugCurrentState()
        }
    }
    
    private func debugCurrentState() {
        let keyState = CGEventSource.keyState(.combinedSessionState, key: Self.fnKeyCode)
        logger.notice("Debug: fn key polling=\(keyState ? "PRESSED" : "RELEASED"), internal=\(self.fnKeyPressed ? "PRESSED" : "RELEASED"), factor=\(self.precisionFactor)")
        logger.notice("Event stats: total=\(self.eventCount), scaled=\(self.scaledEventCount)")
        
        // Check secure input mode periodically
        if IsSecureEventInputEnabled() {
            logger.warning("Secure input mode is active")
        }
    }
}

public enum PointerScalerError: LocalizedError {
    case failedToCreateEventTap
    
    public var errorDescription: String? {
        switch self {
        case .failedToCreateEventTap:
            return "Failed to create event tap. Please ensure accessibility permissions are granted."
        }
    }
}
</file>

<file path="Tests/DragobooCoreTests/PointerScalerTests.swift">
import XCTest
@testable import DragobooCore

final class PointerScalerTests: XCTestCase {
    func testPrecisionFactorInitialization() {
        let scaler = PointerScaler(precisionFactor: 4.0)
        XCTAssertNotNil(scaler)
    }
    
    func testPrecisionFactorUpdate() {
        let scaler = PointerScaler(precisionFactor: 4.0)
        scaler.updatePrecisionFactor(8.0)
        XCTAssertNotNil(scaler)
    }
}
</file>

<file path=".cursorindexingignore">
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**
</file>

<file path="Info.plist">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleExecutable</key>
    <string>Dragoboo</string>
    <key>CFBundleIdentifier</key>
    <string>com.dragoboo.app</string>
    <key>CFBundleName</key>
    <string>Dragoboo</string>
    <key>CFBundleDisplayName</key>
    <string>Dragoboo</string>
    <key>CFBundleVersion</key>
    <string>1.0</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0</string>
    <key>CFBundlePackageType</key>
    <string>APPL</string>
    <key>CFBundleInfoDictionaryVersion</key>
    <string>6.0</string>
    <key>LSMinimumSystemVersion</key>
    <string>13.0</string>
    <key>LSUIElement</key>
    <true/>
    <key>NSPrincipalClass</key>
    <string>NSApplication</string>
    <key>NSHumanReadableCopyright</key>
    <string>Copyright © 2025. All rights reserved.</string>
    <key>NSHighResolutionCapable</key>
    <true/>
    <key>LSApplicationCategoryType</key>
    <string>public.app-category.utilities</string>
</dict>
</plist>
</file>

<file path="Makefile">
.PHONY: all build run clean stop release help

# Default target
all: run

# Build the app
build:
	@./run.sh --no-launch

# Build and run the app
run:
	@./run.sh

# Clean build
clean:
	@echo "Cleaning build directory..."
	@rm -rf .build
	@rm -rf build
	@echo "Clean complete"

# Stop the running app
stop:
	@./stop.sh

# Build release version
release:
	@./run.sh --release

# Build clean
rebuild: clean build

# Show help
help:
	@echo "Dragoboo Makefile"
	@echo "================"
	@echo "Available targets:"
	@echo "  make         - Build and run the app (default)"
	@echo "  make build   - Build the app without running"
	@echo "  make run     - Build and run the app"
	@echo "  make clean   - Clean build directory"
	@echo "  make stop    - Stop the running app"
	@echo "  make release - Build release version"
	@echo "  make rebuild - Clean and rebuild"
	@echo "  make help    - Show this help message"
</file>

<file path="Package.swift">
// swift-tools-version: 5.10
import PackageDescription

let package = Package(
    name: "Dragoboo",
    platforms: [
        .macOS(.v13)
    ],
    products: [
        .executable(
            name: "Dragoboo",
            targets: ["DragobooApp"]
        ),
        .library(
            name: "DragobooCore",
            targets: ["DragobooCore"]
        ),
    ],
    dependencies: [],
    targets: [
        .executableTarget(
            name: "DragobooApp",
            dependencies: ["DragobooCore"],
            resources: [
                .process("Assets.xcassets")
            ]
        ),
        .target(
            name: "DragobooCore",
            dependencies: []
        ),
        .testTarget(
            name: "DragobooCoreTests",
            dependencies: ["DragobooCore"]
        ),
    ]
)
</file>

<file path="PLAN.md">
# Dragoboo Development Plan

## Phase 1: Research & Architecture

[ ] Analyze CGEventTap API documentation for mouse event interception
[ ] Research fn key detection methods (CGEventFlags vs keyState polling)
[ ] Investigate accessibility permission handling and user flow
[ ] Document technical constraints and edge cases
[ ] Design modular architecture (DragobooCore + DragobooApp)
[ ] Create system architecture diagram
[ ] Define public API surface for DragobooCore
[ ] Research battery impact mitigation strategies

## Phase 2: Project Setup & Infrastructure

[ ] Create Xcode project with macOS app template
[ ] Configure SwiftUI lifecycle and minimum deployment target (macOS 13.0)
[ ] Set up Swift Package Manager structure
[ ] Create DragobooCore package with proper module organization
[ ] Configure code signing and Developer ID certificate
[ ] Set up SwiftLint with appropriate rules
[ ] Configure swift-format for code consistency
[ ] Create .gitignore with Xcode/Swift patterns
[ ] Initialize git repository with proper structure

## Phase 3: Core Functionality Implementation

[ ] Implement PointerScalerActor for thread-safe event processing
[ ] Create CGEventTap wrapper with proper error handling
[ ] Implement mouse delta scaling algorithm
[ ] Add fn key detection via maskSecondaryFn flag
[ ] Create fallback keyState polling for fn key
[ ] Implement event tap lifecycle management
[ ] Add automatic re-enable for disabled taps
[ ] Create scaling factor validation (0.5-10x range)
[ ] Implement smooth transition between normal/precision modes
[ ] Add support for all mouse event types (move, drag, scroll)

## Phase 4: Modifier Key Management

[ ] Create KeyStateManager for modifier tracking
[ ] Implement flagsChanged event monitoring
[ ] Add support for custom modifier keys beyond fn
[ ] Create modifier key combination support
[ ] Implement edge case handling for stuck keys
[ ] Add modifier state persistence across app switches
[ ] Create debugging output for key state changes

## Phase 5: User Interface Development

[ ] Design MenuBarExtra with SwiftUI
[ ] Create status bar icon (normal vs active states)
[ ] Implement preferences sheet UI
[ ] Add precision factor slider/stepper control
[ ] Create modifier key selection interface
[ ] Implement live preview of settings changes
[ ] Add visual feedback for precision mode activation
[ ] Design onboarding flow for first launch
[ ] Create accessibility permission request UI

## Phase 6: System Integration

[ ] Implement accessibility permission checking
[ ] Create AXIsProcessTrustedWithOptions wrapper
[ ] Add permission status monitoring
[ ] Implement graceful degradation without permissions
[ ] Create LaunchAgent for login startup
[ ] Add proper app termination cleanup
[ ] Implement system sleep/wake handling
[ ] Add display configuration change support

## Phase 7: Performance Optimization

[ ] Profile event tap callback performance
[ ] Implement sub-1ms callback execution
[ ] Add event rate limiting (120 Hz max)
[ ] Create dedicated high-priority dispatch queue
[ ] Minimize CPU usage when idle
[ ] Implement memory usage monitoring
[ ] Add performance metrics logging
[ ] Optimize for battery efficiency

## Phase 8: Persistence & Configuration

[ ] Implement UserDefaults integration with @AppStorage
[ ] Create settings migration system
[ ] Add configuration import/export
[ ] Implement preset management
[ ] Create per-application settings support
[ ] Add backup/restore functionality

## Phase 9: Error Handling & Logging

[ ] Set up os.Logger infrastructure
[ ] Implement comprehensive error handling
[ ] Create user-friendly error messages
[ ] Add crash reporting integration
[ ] Implement diagnostic data collection
[ ] Create debug mode with verbose logging
[ ] Add event tap failure recovery

## Phase 10: Testing Strategy

[ ] Write unit tests for scaling math
[ ] Create integration tests for event processing
[ ] Implement UI tests for preferences
[ ] Add performance benchmarks
[ ] Test with multiple input devices
[ ] Verify behavior across macOS versions
[ ] Test with external keyboards (fn key compatibility)
[ ] Create automated test suite

## Phase 11: Edge Cases & Compatibility

[ ] Handle multiple displays with different DPIs
[ ] Test with gaming mice (high DPI)
[ ] Verify Magic Trackpad compatibility
[ ] Handle Bluetooth disconnection/reconnection
[ ] Test with Touch Bar MacBooks
[ ] Verify M1/M2/M3 compatibility
[ ] Handle full screen games/apps
[ ] Test with virtual machines

## Phase 12: Documentation

[ ] Write comprehensive README
[ ] Create user guide with screenshots
[ ] Document accessibility setup process
[ ] Write API documentation for DragobooCore
[ ] Create troubleshooting guide
[ ] Document known limitations
[ ] Write contribution guidelines
[ ] Create changelog structure

## Phase 13: Distribution & Packaging

[ ] Configure hardened runtime
[ ] Set up notarization workflow
[ ] Create DMG installer with background
[ ] Implement auto-update mechanism (Sparkle)
[ ] Create Homebrew cask formula
[ ] Set up GitHub releases automation
[ ] Create installation verification
[ ] Implement license validation (if commercial)

## Phase 14: Quality Assurance

[ ] Perform thorough manual testing
[ ] Run static analysis tools
[ ] Check for memory leaks
[ ] Verify accessibility compliance
[ ] Test localization support
[ ] Validate security best practices
[ ] Performance regression testing
[ ] User acceptance testing

## Phase 15: Release & Post-Launch

[ ] Create marketing website
[ ] Set up user feedback channels
[ ] Implement analytics (privacy-respecting)
[ ] Create support documentation
[ ] Monitor crash reports
[ ] Plan feature roadmap
[ ] Set up community forum
[ ] Establish update cadence
</file>

<file path="README.md">
# Dragoboo 🐉🖱️

**Dragoboo is a macOS utility designed to give you an instant precision boost for your trackpad and mouse. By simply holding down the `fn` key, you can temporarily slow down your cursor movement, allowing for finer control in detailed tasks.**

Whether you're a designer pixel-peeping in an image editor, an engineer working with CAD software, or just someone who occasionally needs that extra bit of accuracy, Dragoboo aims to make your pointer interactions smoother and more precise without interrupting your workflow.

[![macOS](https://img.shields.io/badge/macOS-13.0+-blue.svg)](https://www.apple.com/macos) [![Swift](https://img.shields.io/badge/Swift-5.10-orange.svg)](https://swift.org) [![SwiftUI](https://img.shields.io/badge/SwiftUI-Framework-purple.svg)](https://developer.apple.com/xcode/swiftui/) [![License](https://img.shields.io/badge/License-MIT-green.svg)](LICENSE) ## Table of Contents

- [Features](#features)
- [Why Dragoboo?](#why-dragoboo)
- [User Experience (UX)](#user-experience-ux)
  - [Installation](#installation)
  - [First Launch & Permissions](#first-launch--permissions)
  - [Usage](#usage)
  - [Settings](#settings)
- [Technical Deep Dive](#technical-deep-dive)
  - [Core Architecture](#core-architecture)
  - [Event Handling](#event-handling)
  - [State Management](#state-management)
  - [Key Components](#key-components)
- [Getting Started](#getting-started)
  - [Prerequisites](#prerequisites)
  - [Building from Source](#building-from-source)
    - [Using the Command Line (Recommended)](#using-the-command-line-recommended)
    - [Using Xcode](#using-xcode)
  - [Running the App](#running-the-app)
  - [Stopping the App](#stopping-the-app)
- [Configuration](#configuration)
- [Privacy & Security](#privacy--security)
- [Development Insights](#development-insights)
  - [Project Structure](#project-structure)
  - [Planning & Roadmap](#planning--roadmap)
  - [Testing](#testing)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Acknowledgements](#acknowledgements)

## Features

- **Instant Precision Mode:** Hold the `fn` key to temporarily reduce cursor sensitivity.
- **Customizable Slowdown Factor:** Adjust how much the cursor slows down (from 1x to 10x) via a simple slider in the menu bar popover. Default is 4x.
- **Menu Bar App:** Lives discreetly in your macOS menu bar, providing quick access to settings without cluttering your Dock.
- **Universal Support:** Works with both built-in trackpads and external mice.
- **Comprehensive Action Coverage:** Precision mode applies to standard cursor movements, dragging actions (left, right, other), and even scroll wheel events.
- **SwiftUI Interface:** Modern and clean user interface for settings.
- **Lightweight:** Designed to be efficient and have minimal impact on system performance.
- **Accessibility Focused:** Requires and guides users through granting necessary Accessibility permissions.

## Why Dragoboo?

Many creative and technical tasks on a Mac require precise cursor placement. While macOS offers global tracking speed adjustments, these are cumbersome to change frequently. Dragoboo provides an "on-demand" precision mode, activated by a key you already have: the `fn` key. This allows for quick switching between fast navigation and meticulous control without needing to dive into System Settings or use complex third-party tools.

The core idea was born out of a need for finer trackpad control during detailed graphical work, as detailed in the initial [research document (`_private/research.md`)](_private/research.md).

## User Experience (UX)

### Installation

Dragoboo is typically run from the build output. Once built (see [Building from Source](#building-from-source)), the `Dragoboo.app` bundle can be placed in your `/Applications` folder or run from any location.

### First Launch & Permissions

Upon first launch, Dragoboo will check if it has the necessary **Accessibility permissions**. These permissions are crucial for the app to monitor and modify mouse/trackpad events system-wide.

1.  If permissions are not granted, the app's menu bar popover will display a message prompting you to grant them.
2.  Clicking the "Grant Permission" button will attempt to open **System Settings > Privacy & Security > Accessibility**.
3.  You will need to find "Dragoboo" in the list and enable it. You might need to unlock System Settings with your administrator password.

Without these permissions, Dragoboo cannot function.

### Usage

Once installed and permissions are granted:

1.  **Launch Dragoboo:** The app icon (a cursor arrow) will appear in your macOS menu bar.
2.  **Activate Precision Mode:** Simply **press and hold the `fn` key** on your keyboard. While the `fn` key is held, your cursor (and scrolling) will move significantly slower, based on the configured slowdown factor.
3.  **Release `fn` Key:** Release the `fn` key to return to normal cursor speed.

The menu bar icon will change to indicate when precision mode is active (e.g., from `cursorarrow` to `cursorarrow.click.2`).

### Settings

Click the Dragoboo icon in the menu bar to open a small popover window:

- **Accessibility Status:** Shows if permissions are granted.
- **Slowdown Factor Slider:** Adjust the precision multiplier from 1x (no slowdown) to 10x. The default is 4x. Changes are applied live.
- **Precision Mode Indicator:** A label confirms "Precision mode active" when the `fn` key is held.
- **Status Indicator:** A small circle (gray for ready, green for active) and text provide a quick visual cue.
- **Quit Button:** To close the application.

## Technical Deep Dive

### Core Architecture

Dragoboo follows a modular design:

- **`DragobooApp` (SwiftUI Application):**

  - Manages the main application lifecycle.
  - Provides the `MenuBarExtra` user interface using SwiftUI.
  - Hosts the `AppState` observable object to bridge UI and core logic.
  - Located in `Dragoboo/Dragoboo/DragobooApp.swift`.

- **`DragobooCore` (Swift Package):**
  - Contains the core logic for event handling and pointer scaling.
  - This separation allows the core functionality to be potentially reused or tested independently.
  - The primary class here is `PointerScaler`.
  - Located in `Sources/DragobooCore/`.

### Event Handling

The heart of Dragoboo is its ability to intercept and modify system-wide input events. This is achieved using macOS's **Quartz Event Services**, specifically `CGEvent.tapCreate`:

1.  **Event Tap Creation:** An event tap is established at the `.cgSessionEventTap` point, placed at `.headInsertEventTap` to process events before other applications.
2.  **Events of Interest:** The tap listens for:
    - `mouseMoved`
    - `leftMouseDragged`, `rightMouseDragged`, `otherMouseDragged`
    - `scrollWheel`
    - `flagsChanged` (to detect `fn` key state changes)
3.  **Callback Mechanism:** A C-style callback function (`eventTapCallback` in the initial research, now encapsulated within `PointerScaler`) is invoked for each relevant event.
4.  **`fn` Key Detection:**
    - The primary method is checking the `flags` of an incoming event for `.maskSecondaryFn`. This is handled within the `flagsChanged` event type.
    - As a fallback and for continuous state checking during mouse/scroll events, `CGEventSource.keyState(.combinedSessionState, key: 0x3F)` is used to poll the `fn` key's state (key code `0x3F` is for `fn`).
5.  **Delta Scaling:**
    - When the `fn` key is detected as pressed, the `PointerScaler` retrieves the delta values from mouse movement or scroll wheel events (e.g., `.mouseEventDeltaX`, `.mouseEventDeltaY`, `.scrollWheelEventDeltaAxis1`).
    - These delta values are then divided by the `precisionFactor`.
    - The modified delta values are written back into the event using `setDoubleValueField`.
    - The modified event is then passed on to the system.
6.  **Run Loop Integration:** The event tap is added to the current run loop to ensure it processes events continuously.
7.  **Error Handling:** The system includes logging for event tap creation failures and attempts to re-enable the tap if it's disabled by timeout or user input.

### State Management

- **`AppState` (ObservableObject):** This class in `DragobooApp.swift` serves as the central point for managing the application's state and acts as a ViewModel.
  - `@Published var isPrecisionModeActive`: Tracks if the `fn` key is currently pressed.
  - `@Published var isAccessibilityGranted`: Reflects the status of Accessibility permissions.
  - `@AppStorage("precisionFactor") var precisionFactor: Double`: Persists the user-selected slowdown factor using `UserDefaults`.
  - It initializes and manages the `PointerScaler` instance from `DragobooCore`.
  - Communicates changes from `PointerScaler` (like `fn` key state) to the SwiftUI UI via its `onPrecisionModeChange` callback.

### Key Components

- **`DragobooApp.swift`:**
  - `DragobooApp`: The main `@main` struct defining the app and its `MenuBarExtra` scene.
  - `AppState`: Manages overall application state, permissions, and interaction with `PointerScaler`.
- **`ContentView.swift`:**
  - `ContentView`: The main SwiftUI view for the menu bar popover.
  - `AccessibilityRequestView`: Shown if permissions are not granted.
  - `PrecisionSettingsView`: Allows adjustment of the slowdown factor.
  - `StatusIndicator`: Visual feedback for precision mode.
- **`PointerScaler.swift` (in `DragobooCore`):**
  - The core engine responsible for creating and managing the `CGEventTap`.
  - Handles event callbacks, `fn` key detection logic, and scaling of mouse/scroll deltas.
  - Provides an `onPrecisionModeChange` callback to notify `AppState` of `fn` key status.
  - Manages its own lifecycle with `start()` and `stop()` methods.
- **`Info.plist`:**
  - Configures the app as a "UI Element" (`LSUIElement = true`), so it runs as a menu bar agent without a Dock icon.
  - Specifies the minimum macOS deployment target.

## Getting Started

### Prerequisites

- **macOS:** Version 13.0 or later.
- **Xcode:** Version 15.0 or later (for building from source).
- **Xcode Command Line Tools:** Required for `xcodebuild`. Install via `xcode-select --install`.
- **(Optional) `xcpretty`:** For nicer build output in the terminal. Install via `gem install xcpretty`. The `run.sh` script will fall back if it's not found.

### Building from Source

You can build Dragoboo using the provided shell script or directly within Xcode.

#### Using the Command Line (Recommended)

The repository includes a `run.sh` script to simplify the build and run process.

1.  **Clone the repository:**
    ```bash
    git clone <repository-url>
    cd dragoboo
    ```
2.  **Make scripts executable (if needed):**
    ```bash
    chmod +x run.sh stop.sh
    ```
3.  **Build and Run:**

    ```bash
    ./run.sh
    ```

    This will:

    - Clean the build directory (optional, can be forced with `--clean`).
    - Build the app in Debug configuration.
    - Launch the app.

4.  **Other `run.sh` options:**

    - `./run.sh --help`: Show all available script options.
    - `./run.sh --release`: Build in Release configuration.
    - `./run.sh --clean`: Force a clean build before building.
    - `./run.sh --no-launch`: Build the app but do not launch it.

    A `Makefile` is also provided for common tasks:

    ```bash
    make          # Build and run (default)
    make build    # Build without running
    make clean    # Clean build directory
    make release  # Build release version
    make rebuild  # Clean and then build
    make help     # Show Makefile help
    ```

#### Using Xcode

1.  Open `Dragoboo.xcodeproj` in Xcode.
2.  Select the "Dragoboo" scheme and a macOS run destination (My Mac).
3.  Click the "Build and Run" button (or press `⌘R`).

### Running the App

After building, the `Dragoboo.app` bundle will be located in the `build/Build/Products/<Configuration>/` directory (e.g., `build/Build/Products/Debug/Dragoboo.app`).

You can launch it by:

- Using `./run.sh` (which handles launching).
- Double-clicking `Dragoboo.app` in Finder.
- Running `open build/Build/Products/Debug/Dragoboo.app` from the terminal (adjust path if built in Release).

### Stopping the App

- Click the Dragoboo icon in the menu bar and select "Quit".
- Run `./stop.sh` from the terminal.
- If run from Xcode, stopping the process in Xcode will terminate the app.

## Configuration

The primary configuration option is the **Slowdown Factor**, adjustable from 1x to 10x using the slider in the menu bar popover. This setting is persisted across app launches using `@AppStorage` (which relies on `UserDefaults`).

## Privacy & Security

- **Accessibility Permissions:** Dragoboo **requires** Accessibility permissions in **System Settings > Privacy & Security > Accessibility**. This is essential for the app to monitor and modify mouse and keyboard events system-wide. The app will guide you to grant these permissions.
- **No Data Collection:** Dragoboo does not collect, store, or transmit any personal data.
- **No Network Connectivity:** The app does not connect to the internet.
- **Local Operation:** All event processing and modification happen locally on your Mac.
- **Targeted Modification:** Event modification only occurs when the `fn` key is actively held down.

## Development Insights

### Project Structure

Dragoboo/├── Dragoboo.xcodeproj # Xcode project file├── Dragoboo/ # Main application target group│ ├── DragobooApp.swift # App entry point, MenuBarExtra, AppState│ ├── ContentView.swift # SwiftUI views for the popover│ ├── Assets.xcassets # App icons and other assets│ └── Info.plist # Application configuration├── Sources/│ └── DragobooCore/ # Swift Package for core logic│ └── PointerScaler.swift # Event tap and scaling logic├── Tests/│ └── DragobooCoreTests/ # Unit tests for DragobooCore│ └── PointerScalerTests.swift├── \_private/│ └── research.md # Initial research and planning├── Package.swift # Swift Package Manager manifest├── README.md # This file├── PLAN.md # Detailed development plan├── TODO.md # Short-term tasks├── Makefile # Makefile for build automation├── run.sh # Build and run script└── stop.sh # Script to stop the app

### Planning & Roadmap

The development process is guided by:

- [`PLAN.md`](PLAN.md): A comprehensive checklist of development phases and deliverables, covering research, implementation, testing, and release.
- [`TODO.md`](TODO.md): A list of immediate, actionable tasks for the current development sprint.
- [`CLAUDE.md`](CLAUDE.md): Contains initial guidelines and thoughts on implementation, particularly regarding API choices and architectural decisions.

### Testing

- **Unit Tests:** Basic unit tests for `DragobooCore` are located in `Tests/DragobooCoreTests/`. These currently cover `PointerScaler` initialization and factor updates.
- **Manual Testing:** Crucial for verifying the end-to-end UX, `fn` key interaction, and behavior across different applications and input devices.

## Troubleshooting

- **App Not Working / No Slowdown:**
  1.  **Check Accessibility Permissions:** Ensure Dragoboo is enabled in **System Settings > Privacy & Security > Accessibility**. This is the most common reason for the app not functioning. Try toggling the permission off and on.
  2.  **Restart Dragoboo:** Quit the app from its menu bar icon and relaunch it.
  3.  **Check `fn` Key Configuration:** On some MacBooks, the `fn` key might be configured to perform its special feature (e.g., Show Emoji & Symbols, Start Dictation) instead of acting as a standard modifier. Check **System Settings > Keyboard > Keyboard > Press fn key to...**. For Dragoboo to work best, this should ideally be set to "Do Nothing" or a setting that doesn't conflict. Dragoboo attempts to detect the `fn` key regardless, but system-level interception might interfere.
- **`xcpretty` Not Found (during `./run.sh`):**
  - The `run.sh` script will fall back to standard `xcodebuild` output. If you want prettier output, install `xcpretty`: `sudo gem install xcpretty`.
- **CoreSimulator Version Mismatch (Build Error):**
  - This error (`CoreSimulator is out of date...`) might appear if your Xcode or macOS is not fully up-to-date, or if there's a mismatch between Xcode's components.
  - Ensure macOS and Xcode are updated to their latest compatible versions.
  - Sometimes, restarting your Mac or reinstalling Xcode Command Line Tools (`sudo rm -rf /Library/Developer/CommandLineTools; xcode-select --install`) can help. This error primarily affects simulator builds, which Dragoboo doesn't rely on for its core functionality.
- **`fn` Key on External Keyboards:**
  - The reliability of `fn` key detection can vary with third-party external keyboards. Dragoboo is primarily tested with built-in MacBook keyboards and Apple Magic Keyboards. If you experience issues, this might be a limitation.

## Contributing

Contributions are welcome! If you'd like to contribute, please:

1.  Fork the repository.
2.  Create a new branch for your feature or bug fix.
3.  Refer to `PLAN.md` and `TODO.md` for areas of development.
4.  Follow the existing code style and architectural patterns.
5.  Write tests for new functionality if applicable.
6.  Submit a pull request with a clear description of your changes.

## License

This project is licensed under the MIT License. See the [LICENSE](LICENSE) file for details. _(Note: A `LICENSE` file was not explicitly provided in the source; assuming MIT as a common open-source license. Please create/update this file if a different license applies.)_

## Acknowledgements

- The initial research and problem statement that inspired Dragoboo.
- The macOS developer community for resources on `CGEventTap` and SwiftUI.

## Reminders for contributors

- **Readability > cleverness.** Clear names & comments.
- **Fail safely.** If the tap can’t activate, surface a user-friendly banner and exit.
- **Keep PLAN.md & TODO.md living documents.** Update as you learn.
- **Commit often, push daily.** Small PRs enable fast review.

## Development Guidelines

- Only modify code directly relevant to the specific request. Avoid changing unrelated functionality.
- Never replace code with placeholders like `# ... rest of the processing ...`. Always include complete code.
- Break problems into smaller steps. Think through each step separately before implementing.
- Always provide a complete PLAN with REASONING based on evidence from code and logs before making changes.
- Explain your OBSERVATIONS clearly, then provide REASONING to identify the exact issue. Add console logs when needed to gather more information.

Dragoboo is a macOS utility that provides precision cursor control through temporary slowdown functionality.

## Core Business Logic

### Precision Control System

- Activates temporary cursor slowdown when fn key is held
- Scales both cursor movement and scroll wheel input
- Configurable slowdown factor (1x-10x)
- Persists user preferences across sessions
- Works universally with trackpads and mice

### Event Processing Pipeline

The event interception and modification system:

1. Creates system-wide event tap for mouse/trackpad inputs
2. Monitors fn key state continuously
3. Applies precision scaling to movement deltas when active
4. Handles multiple event types including movement, dragging, and scrolling

### Permission Management

- Requires macOS Accessibility permissions
- Guides users through permission granting process
- Validates permission status on launch
- Prevents operation without proper access

### State Management System

Centralizes control through AppState which:

- Tracks precision mode status
- Manages accessibility permissions
- Controls slowdown factor settings
- Coordinates UI feedback

## Critical Components

### Core Files

- `DragobooApp.swift`: Application entry point and state coordination
- `PointerScaler.swift`: Event interception and scaling engine
- `ContentView.swift`: UI feedback and settings interface

### Key Integrations

- Event tap system for system-wide input capture
- Accessibility permissions framework
- User defaults for persistence
- Menu bar integration for status and control

### Data Flow

1. System input events → Event tap
2. Event tap → Pointer scaler
3. Pointer scaler → Modified events
4. State changes → UI updates
</file>

<file path="run.sh">
#!/bin/bash

# Dragoboo SPM build and run script
# This script builds and runs the Dragoboo app using Swift Package Manager

set -e # Exit on error

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

# Check if swift is available
if ! command -v swift &>/dev/null; then
    print_error "Swift not found. Please install Xcode or Swift toolchain."
    exit 1
fi

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$SCRIPT_DIR"

# Configuration
APP_NAME="Dragoboo"
BUILD_DIR=".build"
EXECUTABLE_NAME="Dragoboo"
APP_BUNDLE_DIR="build"
APP_BUNDLE_NAME="Dragoboo.app"

# Parse command line arguments
CLEAN_BUILD=false
RELEASE_BUILD=false
NO_LAUNCH=false

while [[ $# -gt 0 ]]; do
    case $1 in
    --clean)
        CLEAN_BUILD=true
        shift
        ;;
    --release)
        RELEASE_BUILD=true
        shift
        ;;
    --no-launch)
        NO_LAUNCH=true
        shift
        ;;
    --help | -h)
        echo "Usage: $0 [options]"
        echo "Options:"
        echo "  --clean      Clean build directory before building"
        echo "  --release    Build in Release configuration"
        echo "  --no-launch  Build only, don't launch the app"
        echo "  --help       Show this help message"
        exit 0
        ;;
    *)
        print_error "Unknown option: $1"
        echo "Use --help for usage information"
        exit 1
        ;;
    esac
done

# Clean build directory if requested
if [ "$CLEAN_BUILD" = true ]; then
    print_status "Cleaning build directory..."
    rm -rf "$BUILD_DIR"
    rm -rf "$APP_BUNDLE_DIR"
fi

print_status "Building $APP_NAME with Swift Package Manager..."

# Build the project
if [ "$RELEASE_BUILD" = true ]; then
    print_status "Building in Release mode..."
    swift build --configuration release
    EXECUTABLE_PATH="$BUILD_DIR/release/$EXECUTABLE_NAME"
else
    print_status "Building in Debug mode..."
    swift build
    EXECUTABLE_PATH="$BUILD_DIR/debug/$EXECUTABLE_NAME"
fi

# Check if build succeeded
if [ $? -ne 0 ]; then
    print_error "Build failed!"
    exit 1
fi

print_status "Build completed successfully!"

# Check if executable exists
if [ ! -f "$EXECUTABLE_PATH" ]; then
    print_error "Could not find built executable at: $EXECUTABLE_PATH"
    exit 1
fi

print_status "Found executable at: $EXECUTABLE_PATH"

# Create .app bundle
print_status "Creating .app bundle..."
APP_BUNDLE_PATH="$APP_BUNDLE_DIR/$APP_BUNDLE_NAME"
CONTENTS_DIR="$APP_BUNDLE_PATH/Contents"
MACOS_DIR="$CONTENTS_DIR/MacOS"
RESOURCES_DIR="$CONTENTS_DIR/Resources"

# Create bundle directory structure
mkdir -p "$MACOS_DIR"
mkdir -p "$RESOURCES_DIR"

# Copy executable to bundle
cp "$EXECUTABLE_PATH" "$MACOS_DIR/$EXECUTABLE_NAME"
chmod +x "$MACOS_DIR/$EXECUTABLE_NAME"

# Copy Info.plist to bundle
if [ -f "Info.plist" ]; then
    cp "Info.plist" "$CONTENTS_DIR/"
    print_status "Copied Info.plist to bundle"
else
    print_error "Info.plist not found! Please ensure Info.plist exists in the project root."
    exit 1
fi

# Copy Assets.xcassets if it exists in Sources/DragobooApp/
if [ -d "Sources/DragobooApp/Assets.xcassets" ]; then
    cp -r "Sources/DragobooApp/Assets.xcassets" "$RESOURCES_DIR/"
    print_status "Copied Assets.xcassets to bundle"
fi

print_status "App bundle created at: $APP_BUNDLE_PATH"

# Update executable path to point to bundle
EXECUTABLE_PATH="$MACOS_DIR/$EXECUTABLE_NAME"
APP_LAUNCH_PATH="$APP_BUNDLE_PATH"

# Exit here if --no-launch was specified
if [ "$NO_LAUNCH" = true ]; then
    print_status "Build complete. App bundle location: $APP_BUNDLE_PATH"
    exit 0
fi

# Check if app is already running and kill it
APP_PID=$(pgrep -f "$APP_BUNDLE_NAME" || true)
if [ -n "$APP_PID" ]; then
    print_warning "Dragoboo is already running (PID: $APP_PID). Terminating..."
    kill "$APP_PID" 2>/dev/null || true
    sleep 1
fi

# Check accessibility permissions
print_warning "Note: Dragoboo requires accessibility permissions to function."
print_warning "You may be prompted to grant permissions in System Settings."

# Launch the app bundle
print_status "Launching $APP_NAME from: $APP_BUNDLE_PATH"
open "$APP_BUNDLE_PATH"

# Wait a moment for the app to start
sleep 2

# Check if app is running
if pgrep -f "$APP_BUNDLE_NAME" >/dev/null; then
    print_status "Dragoboo is now running!"
    print_status "Look for the cursor icon in your menu bar"
    print_status "Hold the fn key while moving your trackpad/mouse for precision mode"
    echo ""
    print_warning "To stop Dragoboo: Use ./stop.sh or kill the process"
else
    print_error "Failed to launch Dragoboo"
    exit 1
fi
</file>

<file path="stop.sh">
#!/bin/bash

# Dragoboo stop script
# This script stops the running Dragoboo app

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[✓]${NC} $1"
}

print_error() {
    echo -e "${RED}[✗]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[!]${NC} $1"
}

EXECUTABLE_NAME="Dragoboo.app"

# Find Dragoboo process
APP_PID=$(pgrep -f "$EXECUTABLE_NAME" || true)

if [ -z "$APP_PID" ]; then
    print_warning "Dragoboo is not running"
    exit 0
fi

print_status "Found Dragoboo running (PID: $APP_PID)"
print_status "Stopping Dragoboo..."

# Try graceful termination first
kill "$APP_PID" 2>/dev/null

# Wait for process to terminate
sleep 1

# Check if still running
if pgrep -f "$EXECUTABLE_NAME" >/dev/null; then
    print_warning "Dragoboo didn't stop gracefully, forcing termination..."
    kill -9 "$APP_PID" 2>/dev/null || true
fi

# Final check
if pgrep -f "$EXECUTABLE_NAME" >/dev/null; then
    print_error "Failed to stop Dragoboo"
    exit 1
else
    print_status "Dragoboo stopped successfully"
fi
</file>

<file path="TODO.md">
Even if the app indicates "active", even after permission is granted, **holding the `fn` key does NOT slow the pointer**.  

Read the full codebase from @llms.txt , analyze it, and send it to `deepseek/deepseek-r1-0528:free` via `chat_completion`, and then to `openai/o3` via `chat_completion`, asking the right questions. Talk to `perplexity_ask`. Reason aloud yourself.
</file>

<file path=".gitignore">
# Xcode
build/
*.pbxuser
!default.pbxuser
*.mode1v3
!default.mode1v3
*.mode2v3
!default.mode2v3
*.perspectivev3
!default.perspectivev3
xcuserdata/
*.xccheckout
*.moved-aside
DerivedData/
*.hmap
*.ipa
*.xcuserstate
project.xcworkspace/
.swiftpm/

# macOS
.DS_Store
.AppleDouble
.LSOverride
Icon
._*
.DocumentRevisions-V100
.fseventsd
.Spotlight-V100
.TemporaryItems
.Trashes
.VolumeIcon.icns
.com.apple.timemachine.donotpresent
.AppleDB
.AppleDesktop
Network Trash Folder
Temporary Items
.apdisk

# Swift Package Manager
.build/
Package.resolved

# CocoaPods
Pods/

# Carthage
Carthage/Build/

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Code Injection
iOSInjectionProject/
</file>

</files>
.
├── _private
│   └── research.md
├── build
│   └── Dragoboo.app
│       └── Contents
│           ├── Info.plist
│           ├── MacOS
│           │   └── Dragoboo
│           └── Resources
│               └── Assets.xcassets
│                   ├── AppIcon.appiconset
│                   └── Contents.json
├── CLAUDE.md
├── dragoboo_console.log
├── dragoboo_output.log
├── Info.plist
├── llms.txt
├── Makefile
├── Package.swift
├── PLAN.md
├── README.md
├── run.sh
├── Sources
│   ├── DragobooApp
│   │   ├── Assets.xcassets
│   │   │   ├── AppIcon.appiconset
│   │   │   └── Contents.json
│   │   ├── ContentView.swift
│   │   └── DragobooApp.swift
│   └── DragobooCore
│       └── PointerScaler.swift
├── stop.sh
├── Tests
│   └── DragobooCoreTests
│       └── PointerScalerTests.swift
└── TODO.md

16 directories, 21 files
